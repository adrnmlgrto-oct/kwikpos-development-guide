{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the KwikPOS Developer Guide ! This documentation is designed to help developers onboard quickly and become productive members of the KwikPOS development team. What is KwikPOS? KwikPOS is a modern, offline-first Point of Sale (POS) system built to streamline food and retail operations with features including inventory management, sales tracking, and advanced analytics. Key Advantage: Unlike cloud-based POS systems, KwikPOS operates offline-first, ensuring uninterrupted operations even without internet connectivity. We also provide real-time data syncing capabilities to our cloud backend for centralized reporting and analytics. POS Application Types We currently have two versions of POS applications that should be known by a KwikPOS developer. Chase POS (Legacy) This is the POS application that is provided by Chase Tech. This can either be of the two versions: FoodPOS or WinPOS (Retail) . The source code cannot be modified on our end, and we could only do modifications that are applicable outside of the POS. ( e.g. Exporting of sales data for reports ) We normally request modifications through the Chase developer if we really need it, but if we can do it on our end, we should push that instead. KwikPOS Pro This is our main product is currently being developed continuously. We have full control over the source code here so we are able to cater modification requests directly, unlike the legacy POS. Learn More About Our Products Want to see what we're building? Visit our website to explore the KwikPOS product line: Visit KwikPOS Website \u2192 Get Started Ready to begin? Start with our Getting Started guide to learn about our projects and set up your development environment.","title":"Introduction"},{"location":"index.html#what-is-kwikpos","text":"KwikPOS is a modern, offline-first Point of Sale (POS) system built to streamline food and retail operations with features including inventory management, sales tracking, and advanced analytics. Key Advantage: Unlike cloud-based POS systems, KwikPOS operates offline-first, ensuring uninterrupted operations even without internet connectivity. We also provide real-time data syncing capabilities to our cloud backend for centralized reporting and analytics.","title":"What is KwikPOS?"},{"location":"index.html#pos-application-types","text":"We currently have two versions of POS applications that should be known by a KwikPOS developer. Chase POS (Legacy) This is the POS application that is provided by Chase Tech. This can either be of the two versions: FoodPOS or WinPOS (Retail) . The source code cannot be modified on our end, and we could only do modifications that are applicable outside of the POS. ( e.g. Exporting of sales data for reports ) We normally request modifications through the Chase developer if we really need it, but if we can do it on our end, we should push that instead. KwikPOS Pro This is our main product is currently being developed continuously. We have full control over the source code here so we are able to cater modification requests directly, unlike the legacy POS.","title":"POS Application Types"},{"location":"index.html#learn-more-about-our-products","text":"Want to see what we're building? Visit our website to explore the KwikPOS product line: Visit KwikPOS Website \u2192","title":"Learn More About Our Products"},{"location":"index.html#get-started","text":"Ready to begin? Start with our Getting Started guide to learn about our projects and set up your development environment.","title":"Get Started"},{"location":"about.html","text":"This developer guide was created to help onboard new developers to the KwikPOS ecosystem and provide comprehensive documentation for our projects. Contact For any questions or clarifications about this guide, feel free to reach out at adrnmlgrto.dev@gmail.com . Acknowledgments This guide was created to support future developers and ensure knowledge continuity within the KwikPOS development team. Special thanks to all team members who contributed their insights and feedback.","title":"About this Guide"},{"location":"about.html#contact","text":"For any questions or clarifications about this guide, feel free to reach out at adrnmlgrto.dev@gmail.com .","title":"Contact"},{"location":"about.html#acknowledgments","text":"This guide was created to support future developers and ensure knowledge continuity within the KwikPOS development team. Special thanks to all team members who contributed their insights and feedback.","title":"Acknowledgments"},{"location":"ai-usage-guidelines.html","text":"Our Philosophy on AI in Development At KwikPOS, we encourage the use of AI tools as part of your development workflow. AI assistants like GitHub Copilot, Claude, ChatGPT, and others can significantly boost productivity, help you learn new concepts, and accelerate development. However, we have important guidelines to ensure AI usage remains beneficial and doesn't compromise code quality or your growth as a developer. Core Principle: Understanding Over Automation The developer must always understand what the AI is suggesting. AI is a powerful tool, but it should augment your skills, not replace your understanding . Every line of code that goes into our codebase should be code you comprehend and can maintain. The Golden Rules 1. Always Understand the Code Don't blindly copy-paste AI-generated code without understanding what it does Read through every line of code the AI suggests Understand the logic, patterns, and potential implications If you don't understand something, research it or ask a team member \u274c Wrong Approach: \"AI generated this code. Let me paste it and see if it works.\" \u2705 Right Approach: \"AI suggested this approach. Let me understand why this works, what each part does, and if there are any potential issues.\" 2. The Decision Always Ends with You You are responsible for the code , not the AI AI suggestions are recommendations, not mandates Exercise critical thinking and professional judgment You should be able to explain and defend your code choices 3. Learn, Don't Just Generate Use AI as a learning tool , not just a code generator When AI suggests something new, take time to understand it Ask yourself: \"What did I learn from this AI suggestion?\" Research unfamiliar concepts, libraries, or patterns \u274c Wrong Mindset: \"The AI wrote it, so I don't need to know how it works.\" \u2705 Right Mindset: \"The AI suggested this pattern. Let me understand it so I can apply it myself in the future without AI assistance.\" 4. Verify and Test Don't assume AI-generated code is correct Review for bugs, edge cases, and security issues Test thoroughly - AI can make mistakes Verify that code follows our coding standards and patterns 5. Maintain Code Quality AI might suggest working code that doesn't fit our architecture Ensure AI suggestions align with: Project coding standards Existing patterns in the codebase Security best practices Performance requirements Refactor AI suggestions if needed to match our standards Appropriate AI Usage \u2705 Good Uses of AI Learning and Understanding Explaining unfamiliar code or concepts Understanding error messages Learning new libraries or frameworks Boilerplate and Repetitive Code Generating boilerplate code (with review) Creating test cases Writing documentation Problem-Solving Assistance Brainstorming approaches to a problem Debugging assistance Getting suggestions for optimization Code Review Support Asking AI to review your code for issues Getting suggestions for improvements Identifying potential bugs or security issues Productivity Boosters Autocompletion for routine code Generating SQL queries (with verification) Writing regex patterns (with testing) \u274c Inappropriate AI Usage Blind Implementation Copying code you don't understand Not reviewing AI suggestions before committing Using complex AI-generated solutions without comprehension Avoiding Learning Using AI to avoid learning fundamental concepts Relying on AI instead of reading documentation Never attempting problems without AI first Security-Critical Code Blindly using AI for authentication/authorization logic without thorough review Accepting AI suggestions for security-sensitive operations without verification Using AI-generated encryption or security code without expert review Best Practices 1. Start Without AI Try to solve problems yourself first before asking AI. This strengthens your problem-solving skills. Recommended Approach: Attempt the problem yourself (15-30 minutes) If stuck, research documentation and existing code Use AI for specific questions or to validate your approach Review and understand AI suggestions thoroughly 2. Use AI for Specific Questions Ask targeted questions rather than \"write this entire feature for me.\" \u274c Too Broad: \"Write a complete inventory management system for me.\" \u2705 Specific and Focused: \"I'm implementing inventory tracking. What's the best approach for handling concurrent updates to stock levels?\" 3. Validate Against Documentation Cross-reference AI suggestions with official documentation AI can sometimes provide outdated or incorrect information Verify that suggested libraries/methods are appropriate for our tech stack 4. Code Review Awareness When submitting code for review: - Be transparent if you used significant AI assistance - Be prepared to explain and defend all code, AI-assisted or not - Don't submit code you can't explain or maintain 5. Continuous Learning Keep learning fundamentals even when using AI Use AI to learn new patterns, then practice them independently Set aside time for learning without AI assistance AI Tools We Recommend While you're free to use any AI tool, here are some commonly used ones: GitHub Copilot - IDE integration for code suggestions Claude (Anthropic) - For explanations and complex problem-solving ChatGPT (OpenAI) - General coding assistance Tabnine - AI code completion Codeium - Free AI code completion Red Flags: When AI Usage Goes Wrong Watch out for these warning signs: \u26a0\ufe0f You can't explain code you just wrote \u26a0\ufe0f You're copying code without reading it \u26a0\ufe0f You're not learning anything new from AI suggestions \u26a0\ufe0f You can't solve similar problems without AI \u26a0\ufe0f You're blindly accepting all AI suggestions \u26a0\ufe0f You're using AI to avoid understanding the codebase Examples Example 1: Good AI Usage Scenario: You need to write a SQL query to fetch sales data grouped by date. Good Approach: Write the basic query yourself Use AI to optimize or validate your query Understand why the AI's optimization works Test with real data Learn the optimization technique for future use -- Your initial query SELECT date, SUM(amount) FROM sales GROUP BY date; -- AI suggests adding index and using DATE() function -- You understand why: better performance and proper date grouping SELECT DATE(created_at) as date, SUM(amount) as total FROM sales WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) GROUP BY DATE(created_at) ORDER BY date DESC; -- You learned: DATE() for grouping, date ranges for performance, indexing strategy Example 2: Poor AI Usage Scenario: You need to implement user authentication. \u274c Poor Approach: Ask AI: \"Write complete authentication system for Spring Boot\" Copy entire AI response (200+ lines) Paste into codebase Try to run it Debug errors without understanding the code \u2705 Better Approach: 1. Research Spring Security documentation 2. Look at existing authentication in legacy codebase 3. Ask AI specific questions: - \"What's the difference between session-based and JWT authentication?\" - \"How do I configure Spring Security for REST APIs?\" 4. Implement step by step, understanding each part 5. Review security implications 6. Test thoroughly Remember AI is a tool to make you a better developer , not a replacement for being a developer. The goal is to: \u2705 Write better code faster \u2705 Learn and grow your skills \u2705 Solve problems more efficiently \u2705 Understand concepts more deeply Not to: \u274c Avoid learning \u274c Write code you don't understand \u274c Become dependent on AI for basic tasks Questions? If you're unsure about whether your AI usage is appropriate, ask yourself: Can I explain this code to a teammate? Could I write similar code without AI? Do I understand why this solution works? Have I verified this is correct and secure? If you answer \"no\" to any of these, take more time to understand the code before committing it. Bottom Line: Use AI as a learning partner and productivity tool, but always maintain your understanding, judgment, and responsibility for the code you write.","title":"AI Usage Guidelines"},{"location":"ai-usage-guidelines.html#our-philosophy-on-ai-in-development","text":"At KwikPOS, we encourage the use of AI tools as part of your development workflow. AI assistants like GitHub Copilot, Claude, ChatGPT, and others can significantly boost productivity, help you learn new concepts, and accelerate development. However, we have important guidelines to ensure AI usage remains beneficial and doesn't compromise code quality or your growth as a developer.","title":"Our Philosophy on AI in Development"},{"location":"ai-usage-guidelines.html#core-principle-understanding-over-automation","text":"The developer must always understand what the AI is suggesting. AI is a powerful tool, but it should augment your skills, not replace your understanding . Every line of code that goes into our codebase should be code you comprehend and can maintain.","title":"Core Principle: Understanding Over Automation"},{"location":"ai-usage-guidelines.html#the-golden-rules","text":"","title":"The Golden Rules"},{"location":"ai-usage-guidelines.html#1-always-understand-the-code","text":"Don't blindly copy-paste AI-generated code without understanding what it does Read through every line of code the AI suggests Understand the logic, patterns, and potential implications If you don't understand something, research it or ask a team member \u274c Wrong Approach: \"AI generated this code. Let me paste it and see if it works.\" \u2705 Right Approach: \"AI suggested this approach. Let me understand why this works, what each part does, and if there are any potential issues.\"","title":"1. Always Understand the Code"},{"location":"ai-usage-guidelines.html#2-the-decision-always-ends-with-you","text":"You are responsible for the code , not the AI AI suggestions are recommendations, not mandates Exercise critical thinking and professional judgment You should be able to explain and defend your code choices","title":"2. The Decision Always Ends with You"},{"location":"ai-usage-guidelines.html#3-learn-dont-just-generate","text":"Use AI as a learning tool , not just a code generator When AI suggests something new, take time to understand it Ask yourself: \"What did I learn from this AI suggestion?\" Research unfamiliar concepts, libraries, or patterns \u274c Wrong Mindset: \"The AI wrote it, so I don't need to know how it works.\" \u2705 Right Mindset: \"The AI suggested this pattern. Let me understand it so I can apply it myself in the future without AI assistance.\"","title":"3. Learn, Don't Just Generate"},{"location":"ai-usage-guidelines.html#4-verify-and-test","text":"Don't assume AI-generated code is correct Review for bugs, edge cases, and security issues Test thoroughly - AI can make mistakes Verify that code follows our coding standards and patterns","title":"4. Verify and Test"},{"location":"ai-usage-guidelines.html#5-maintain-code-quality","text":"AI might suggest working code that doesn't fit our architecture Ensure AI suggestions align with: Project coding standards Existing patterns in the codebase Security best practices Performance requirements Refactor AI suggestions if needed to match our standards","title":"5. Maintain Code Quality"},{"location":"ai-usage-guidelines.html#appropriate-ai-usage","text":"","title":"Appropriate AI Usage"},{"location":"ai-usage-guidelines.html#good-uses-of-ai","text":"Learning and Understanding Explaining unfamiliar code or concepts Understanding error messages Learning new libraries or frameworks Boilerplate and Repetitive Code Generating boilerplate code (with review) Creating test cases Writing documentation Problem-Solving Assistance Brainstorming approaches to a problem Debugging assistance Getting suggestions for optimization Code Review Support Asking AI to review your code for issues Getting suggestions for improvements Identifying potential bugs or security issues Productivity Boosters Autocompletion for routine code Generating SQL queries (with verification) Writing regex patterns (with testing)","title":"\u2705 Good Uses of AI"},{"location":"ai-usage-guidelines.html#inappropriate-ai-usage","text":"Blind Implementation Copying code you don't understand Not reviewing AI suggestions before committing Using complex AI-generated solutions without comprehension Avoiding Learning Using AI to avoid learning fundamental concepts Relying on AI instead of reading documentation Never attempting problems without AI first Security-Critical Code Blindly using AI for authentication/authorization logic without thorough review Accepting AI suggestions for security-sensitive operations without verification Using AI-generated encryption or security code without expert review","title":"\u274c Inappropriate AI Usage"},{"location":"ai-usage-guidelines.html#best-practices","text":"","title":"Best Practices"},{"location":"ai-usage-guidelines.html#1-start-without-ai","text":"Try to solve problems yourself first before asking AI. This strengthens your problem-solving skills. Recommended Approach: Attempt the problem yourself (15-30 minutes) If stuck, research documentation and existing code Use AI for specific questions or to validate your approach Review and understand AI suggestions thoroughly","title":"1. Start Without AI"},{"location":"ai-usage-guidelines.html#2-use-ai-for-specific-questions","text":"Ask targeted questions rather than \"write this entire feature for me.\" \u274c Too Broad: \"Write a complete inventory management system for me.\" \u2705 Specific and Focused: \"I'm implementing inventory tracking. What's the best approach for handling concurrent updates to stock levels?\"","title":"2. Use AI for Specific Questions"},{"location":"ai-usage-guidelines.html#3-validate-against-documentation","text":"Cross-reference AI suggestions with official documentation AI can sometimes provide outdated or incorrect information Verify that suggested libraries/methods are appropriate for our tech stack","title":"3. Validate Against Documentation"},{"location":"ai-usage-guidelines.html#4-code-review-awareness","text":"When submitting code for review: - Be transparent if you used significant AI assistance - Be prepared to explain and defend all code, AI-assisted or not - Don't submit code you can't explain or maintain","title":"4. Code Review Awareness"},{"location":"ai-usage-guidelines.html#5-continuous-learning","text":"Keep learning fundamentals even when using AI Use AI to learn new patterns, then practice them independently Set aside time for learning without AI assistance","title":"5. Continuous Learning"},{"location":"ai-usage-guidelines.html#ai-tools-we-recommend","text":"While you're free to use any AI tool, here are some commonly used ones: GitHub Copilot - IDE integration for code suggestions Claude (Anthropic) - For explanations and complex problem-solving ChatGPT (OpenAI) - General coding assistance Tabnine - AI code completion Codeium - Free AI code completion","title":"AI Tools We Recommend"},{"location":"ai-usage-guidelines.html#red-flags-when-ai-usage-goes-wrong","text":"Watch out for these warning signs: \u26a0\ufe0f You can't explain code you just wrote \u26a0\ufe0f You're copying code without reading it \u26a0\ufe0f You're not learning anything new from AI suggestions \u26a0\ufe0f You can't solve similar problems without AI \u26a0\ufe0f You're blindly accepting all AI suggestions \u26a0\ufe0f You're using AI to avoid understanding the codebase","title":"Red Flags: When AI Usage Goes Wrong"},{"location":"ai-usage-guidelines.html#examples","text":"","title":"Examples"},{"location":"ai-usage-guidelines.html#example-1-good-ai-usage","text":"Scenario: You need to write a SQL query to fetch sales data grouped by date. Good Approach: Write the basic query yourself Use AI to optimize or validate your query Understand why the AI's optimization works Test with real data Learn the optimization technique for future use -- Your initial query SELECT date, SUM(amount) FROM sales GROUP BY date; -- AI suggests adding index and using DATE() function -- You understand why: better performance and proper date grouping SELECT DATE(created_at) as date, SUM(amount) as total FROM sales WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) GROUP BY DATE(created_at) ORDER BY date DESC; -- You learned: DATE() for grouping, date ranges for performance, indexing strategy","title":"Example 1: Good AI Usage"},{"location":"ai-usage-guidelines.html#example-2-poor-ai-usage","text":"Scenario: You need to implement user authentication. \u274c Poor Approach: Ask AI: \"Write complete authentication system for Spring Boot\" Copy entire AI response (200+ lines) Paste into codebase Try to run it Debug errors without understanding the code \u2705 Better Approach: 1. Research Spring Security documentation 2. Look at existing authentication in legacy codebase 3. Ask AI specific questions: - \"What's the difference between session-based and JWT authentication?\" - \"How do I configure Spring Security for REST APIs?\" 4. Implement step by step, understanding each part 5. Review security implications 6. Test thoroughly","title":"Example 2: Poor AI Usage"},{"location":"ai-usage-guidelines.html#remember","text":"AI is a tool to make you a better developer , not a replacement for being a developer. The goal is to: \u2705 Write better code faster \u2705 Learn and grow your skills \u2705 Solve problems more efficiently \u2705 Understand concepts more deeply Not to: \u274c Avoid learning \u274c Write code you don't understand \u274c Become dependent on AI for basic tasks","title":"Remember"},{"location":"ai-usage-guidelines.html#questions","text":"If you're unsure about whether your AI usage is appropriate, ask yourself: Can I explain this code to a teammate? Could I write similar code without AI? Do I understand why this solution works? Have I verified this is correct and secure? If you answer \"no\" to any of these, take more time to understand the code before committing it. Bottom Line: Use AI as a learning partner and productivity tool, but always maintain your understanding, judgment, and responsibility for the code you write.","title":"Questions?"},{"location":"getting-started.html","text":"Welcome to the KwikPOS development team! This guide introduces you to our ecosystem of projects and helps you understand what we build and maintain. Before You Begin Before diving into development, make sure you have the necessary knowledge and tools: Review Prerequisites - Essential knowledge (Git, Java, Spring Boot, etc.) and required development tools Verify you have the appropriate JDK version for your project Ensure your development environment is set up correctly Retrieve required credentials and API keys from the project credentials folder Note: The text files containing the credentials in the link above is in a password-protected archive (.zip) file. Ask the development team for the password. Project Ecosystem Our ecosystem consists of cloud-based backend services and on-premise API adapters that work together to provide a complete POS solution. Real-time data syncing enables individual POS applications to communicate with our cloud backend server, consolidating sales records from different client stores and branches. Our Projects We maintain these main projects: 1. KwikPOS Live (Backend) Cloud-based multi-tenant backend system Central data hub for multiple stores and branches Sales analytics and reporting platform Built with Spring Boot 2.7.2 (Java 8) and MySQL 8.0 Deployed on AWS EC2 View detailed documentation \u2192 2. KwikPOS API (Kiosk-to-POS Adapter) On-premise bridge for legacy POS integration Connects modern kiosks to legacy POS systems Data transformation layer for Chase POS compatibility Built with Spring Boot 3.5.4 (Java 17) Deployed on local POS machines View detailed documentation \u2192 3. FullyBooked Integration (WebExt) Client-specific POS integration for FullyBooked bookstore chain Custom integration between KwikPOS and FullyBooked's IMS system Text file-based data import/export (tab-delimited) Database-centric with custom SQL views and queries Built on MS SQL Server View detailed documentation \u2192 Technology Stack Overview Backend Technologies Java 8 - KwikPOS Live (with upgrade plans) Java 11 - FullyBooked Integration (likely, but unconfirmed) Java 17 - KwikPOS API Spring Boot 2.7.2 - KwikPOS Live and FullyBooked Integration Spring Boot 3.5.4 - KwikPOS API Databases MySQL 8.0 - KwikPOS Live primary database MS SQL Server - KwikPOS API and FullyBooked integration Application Servers Apache Tomcat 9.0 - KwikPOS Live and FullyBooked Integration deployment Apache Tomcat 10.0 - KwikPOS API deployment Infrastructure AWS EC2 - Cloud hosting for KwikPOS Live On-Premise - Local POS machine hosting for KwikPOS API and FullyBooked Integration Architecture Comparison Aspect KwikPOS Live KwikPOS API FullyBooked (WebExt) Deployment Cloud (AWS EC2) On-Premise (POS Machine) On-Premise (FullyBooked POS) Scope Multi-tenant Single store Single client (FullyBooked) Purpose Central data hub Kiosk-POS bridge POS-IMS integration Database MySQL 8.0 MS SQL Server MS SQL Server Clients Multiple tenants Individual kiosks FullyBooked stores Integration POS Terminals \u2192 Cloud Kiosks \u2192 Legacy POS POS \u2194 IMS (text files) Java Version Java 8 Java 17 Java 11 (likely) Spring Boot 2.7.2 3.5.4 2.7.2 App Server Tomcat 9.0 Tomcat 10.0 Tomcat 9.0 Primary Tech Spring Boot API Spring Boot API SQL views/queries Your Work Scope As a developer on the KwikPOS team, you'll work on multiple projects depending on the features and requirements. Your work will primarily involve: Backend Development Building and maintaining RESTful APIs for both KwikPOS Live and KwikPOS API Implementing business logic and service layers Developing new features and enhancements Bug fixes and performance optimization Frontend Development Working on the Angular-based frontend for KwikPOS Live Building responsive UI components and pages Integrating with backend REST APIs Implementing forms, validations, and user interactions Managing application state and data flow Database Work A significant portion of your work will involve writing SQL queries across multiple database systems: MySQL - For KwikPOS Live (primary backend database) Microsoft SQL Server - For KwikPOS API, FullyBooked integration, and legacy system integration SQLite - For KwikPOS Pro application local storage PostgreSQL - For Supabase integration You'll be creating, optimizing, and maintaining SQL queries including: Complex SELECT queries with joins and aggregations INSERT , UPDATE , DELETE operations Stored procedures, views, and functions Database migrations and schema changes Query optimization and indexing Full-Stack Responsibilities Both cloud-based (KwikPOS Live) and on-premise (KwikPOS API) development Multi-tenant architecture implementation Legacy system integration and data transformation Testing and deployment across different environments Client-Specific Integrations FullyBooked Integration - Custom SQL views, queries, and text file import/export Writing and optimizing database views for data extraction Creating import procedures for external data sources Maintaining integration-specific documentation Quick Start Steps Check Prerequisites Review the Prerequisites page Install required tools for both Java 8 and Java 17 development Set up database clients for MySQL, SQL Server, SQLite, and PostgreSQL Verify your development environment Get Access & Onboarding Contact your team lead for organization access for the project repositories Request credentials for: AWS access (for KwikPOS Live deployment) Database connections (MySQL, SQL Server, PostgreSQL) On-premise system access (if needed for KwikPOS API testing) Set Up Both Projects Clone both repositories: KwikPOS Live (Java 8, Spring Boot 2.7.2) KwikPOS API (Java 17, Spring Boot 3.5.4) Follow setup instructions in respective project documentation: KwikPOS Live Setup Guide KwikPOS API Setup Guide Verify both projects run locally Familiarize with Database Systems Set up local MySQL database for KwikPOS Live development Install SQL Server Management Studio 19 Get familiar with SQLite (DB Browser for SQLite) Set up PostgreSQL client for Supabase integration Review existing database schemas and query patterns Start Developing Review existing codebase patterns in both projects Understand the database query structure and ORM usage Pick up your first task or ticket Follow team coding standards and SQL best practices Development Workflow Branch Management Create feature branches from main Use descriptive branch names (e.g., feature/add-sales-report ) Code Changes Follow existing code patterns and conventions Write unit tests for new functionality Test locally before committing Code Review Submit pull requests for code review Address review comments, if any are provided Deployment Follow project-specific deployment procedures Coordinate with team for production deployments Getting Help If you need assistance: Technical Questions: Reach out to the development team Access Issues: Contact your team lead for repository and AWS credentials Architecture Questions: Review project-specific documentation or consult senior developers Deployment Issues: Check deployment guides or contact DevOps Prerequisites Help: See the Prerequisites page Additional Resources Prerequisites Guide - Required knowledge and tools KwikPOS Live Documentation - Detailed project guide KwikPOS API Documentation - Detailed project guide FullyBooked (WebExt) - Detailed project guide KwikPOS Website - Product information Welcome to the KwikPOS development team! We're excited to have you on board.","title":"Getting Started"},{"location":"getting-started.html#before-you-begin","text":"Before diving into development, make sure you have the necessary knowledge and tools: Review Prerequisites - Essential knowledge (Git, Java, Spring Boot, etc.) and required development tools Verify you have the appropriate JDK version for your project Ensure your development environment is set up correctly Retrieve required credentials and API keys from the project credentials folder Note: The text files containing the credentials in the link above is in a password-protected archive (.zip) file. Ask the development team for the password.","title":"Before You Begin"},{"location":"getting-started.html#project-ecosystem","text":"Our ecosystem consists of cloud-based backend services and on-premise API adapters that work together to provide a complete POS solution. Real-time data syncing enables individual POS applications to communicate with our cloud backend server, consolidating sales records from different client stores and branches.","title":"Project Ecosystem"},{"location":"getting-started.html#our-projects","text":"We maintain these main projects:","title":"Our Projects"},{"location":"getting-started.html#1-kwikpos-live-backend","text":"Cloud-based multi-tenant backend system Central data hub for multiple stores and branches Sales analytics and reporting platform Built with Spring Boot 2.7.2 (Java 8) and MySQL 8.0 Deployed on AWS EC2 View detailed documentation \u2192","title":"1. KwikPOS Live (Backend)"},{"location":"getting-started.html#2-kwikpos-api-kiosk-to-pos-adapter","text":"On-premise bridge for legacy POS integration Connects modern kiosks to legacy POS systems Data transformation layer for Chase POS compatibility Built with Spring Boot 3.5.4 (Java 17) Deployed on local POS machines View detailed documentation \u2192","title":"2. KwikPOS API (Kiosk-to-POS Adapter)"},{"location":"getting-started.html#3-fullybooked-integration-webext","text":"Client-specific POS integration for FullyBooked bookstore chain Custom integration between KwikPOS and FullyBooked's IMS system Text file-based data import/export (tab-delimited) Database-centric with custom SQL views and queries Built on MS SQL Server View detailed documentation \u2192","title":"3. FullyBooked Integration (WebExt)"},{"location":"getting-started.html#technology-stack-overview","text":"","title":"Technology Stack Overview"},{"location":"getting-started.html#backend-technologies","text":"Java 8 - KwikPOS Live (with upgrade plans) Java 11 - FullyBooked Integration (likely, but unconfirmed) Java 17 - KwikPOS API Spring Boot 2.7.2 - KwikPOS Live and FullyBooked Integration Spring Boot 3.5.4 - KwikPOS API","title":"Backend Technologies"},{"location":"getting-started.html#databases","text":"MySQL 8.0 - KwikPOS Live primary database MS SQL Server - KwikPOS API and FullyBooked integration","title":"Databases"},{"location":"getting-started.html#application-servers","text":"Apache Tomcat 9.0 - KwikPOS Live and FullyBooked Integration deployment Apache Tomcat 10.0 - KwikPOS API deployment","title":"Application Servers"},{"location":"getting-started.html#infrastructure","text":"AWS EC2 - Cloud hosting for KwikPOS Live On-Premise - Local POS machine hosting for KwikPOS API and FullyBooked Integration","title":"Infrastructure"},{"location":"getting-started.html#architecture-comparison","text":"Aspect KwikPOS Live KwikPOS API FullyBooked (WebExt) Deployment Cloud (AWS EC2) On-Premise (POS Machine) On-Premise (FullyBooked POS) Scope Multi-tenant Single store Single client (FullyBooked) Purpose Central data hub Kiosk-POS bridge POS-IMS integration Database MySQL 8.0 MS SQL Server MS SQL Server Clients Multiple tenants Individual kiosks FullyBooked stores Integration POS Terminals \u2192 Cloud Kiosks \u2192 Legacy POS POS \u2194 IMS (text files) Java Version Java 8 Java 17 Java 11 (likely) Spring Boot 2.7.2 3.5.4 2.7.2 App Server Tomcat 9.0 Tomcat 10.0 Tomcat 9.0 Primary Tech Spring Boot API Spring Boot API SQL views/queries","title":"Architecture Comparison"},{"location":"getting-started.html#your-work-scope","text":"As a developer on the KwikPOS team, you'll work on multiple projects depending on the features and requirements. Your work will primarily involve:","title":"Your Work Scope"},{"location":"getting-started.html#backend-development","text":"Building and maintaining RESTful APIs for both KwikPOS Live and KwikPOS API Implementing business logic and service layers Developing new features and enhancements Bug fixes and performance optimization","title":"Backend Development"},{"location":"getting-started.html#frontend-development","text":"Working on the Angular-based frontend for KwikPOS Live Building responsive UI components and pages Integrating with backend REST APIs Implementing forms, validations, and user interactions Managing application state and data flow","title":"Frontend Development"},{"location":"getting-started.html#database-work","text":"A significant portion of your work will involve writing SQL queries across multiple database systems: MySQL - For KwikPOS Live (primary backend database) Microsoft SQL Server - For KwikPOS API, FullyBooked integration, and legacy system integration SQLite - For KwikPOS Pro application local storage PostgreSQL - For Supabase integration You'll be creating, optimizing, and maintaining SQL queries including: Complex SELECT queries with joins and aggregations INSERT , UPDATE , DELETE operations Stored procedures, views, and functions Database migrations and schema changes Query optimization and indexing","title":"Database Work"},{"location":"getting-started.html#full-stack-responsibilities","text":"Both cloud-based (KwikPOS Live) and on-premise (KwikPOS API) development Multi-tenant architecture implementation Legacy system integration and data transformation Testing and deployment across different environments","title":"Full-Stack Responsibilities"},{"location":"getting-started.html#client-specific-integrations","text":"FullyBooked Integration - Custom SQL views, queries, and text file import/export Writing and optimizing database views for data extraction Creating import procedures for external data sources Maintaining integration-specific documentation","title":"Client-Specific Integrations"},{"location":"getting-started.html#quick-start-steps","text":"Check Prerequisites Review the Prerequisites page Install required tools for both Java 8 and Java 17 development Set up database clients for MySQL, SQL Server, SQLite, and PostgreSQL Verify your development environment Get Access & Onboarding Contact your team lead for organization access for the project repositories Request credentials for: AWS access (for KwikPOS Live deployment) Database connections (MySQL, SQL Server, PostgreSQL) On-premise system access (if needed for KwikPOS API testing) Set Up Both Projects Clone both repositories: KwikPOS Live (Java 8, Spring Boot 2.7.2) KwikPOS API (Java 17, Spring Boot 3.5.4) Follow setup instructions in respective project documentation: KwikPOS Live Setup Guide KwikPOS API Setup Guide Verify both projects run locally Familiarize with Database Systems Set up local MySQL database for KwikPOS Live development Install SQL Server Management Studio 19 Get familiar with SQLite (DB Browser for SQLite) Set up PostgreSQL client for Supabase integration Review existing database schemas and query patterns Start Developing Review existing codebase patterns in both projects Understand the database query structure and ORM usage Pick up your first task or ticket Follow team coding standards and SQL best practices","title":"Quick Start Steps"},{"location":"getting-started.html#development-workflow","text":"Branch Management Create feature branches from main Use descriptive branch names (e.g., feature/add-sales-report ) Code Changes Follow existing code patterns and conventions Write unit tests for new functionality Test locally before committing Code Review Submit pull requests for code review Address review comments, if any are provided Deployment Follow project-specific deployment procedures Coordinate with team for production deployments","title":"Development Workflow"},{"location":"getting-started.html#getting-help","text":"If you need assistance: Technical Questions: Reach out to the development team Access Issues: Contact your team lead for repository and AWS credentials Architecture Questions: Review project-specific documentation or consult senior developers Deployment Issues: Check deployment guides or contact DevOps Prerequisites Help: See the Prerequisites page","title":"Getting Help"},{"location":"getting-started.html#additional-resources","text":"Prerequisites Guide - Required knowledge and tools KwikPOS Live Documentation - Detailed project guide KwikPOS API Documentation - Detailed project guide FullyBooked (WebExt) - Detailed project guide KwikPOS Website - Product information Welcome to the KwikPOS development team! We're excited to have you on board.","title":"Additional Resources"},{"location":"prerequisites.html","text":"Before you start developing for KwikPOS projects, ensure you have the necessary knowledge and tools. Required Knowledge Version Control Git fundamentals Cloning repositories Creating and managing branches Committing and pushing changes Pull requests and code reviews Resolving merge conflicts Basic Git workflows (feature branches, main branch) Frontend Development (Angular) Node.js and npm package management TypeScript fundamentals Angular framework basics Components, templates, and data binding Services and dependency injection RxJS and Observables HTTP client and API integration Routing and navigation Angular forms and validation Flutter Development Dart programming language fundamentals Flutter widget system and UI composition State management concepts (setState, Provider, Bloc, etc.) Asynchronous programming (Futures, Streams, async/await) Navigation and routing API integration and HTTP requests Local data persistence (SharedPreferences, SQLite) Flutter app lifecycle and debugging Java Development Core Java programming Object-oriented programming concepts Java collections and data structures Exception handling File I/O operations Multithreading basics Spring Boot Framework Spring Boot fundamentals Dependency injection and IoC containers REST API development Spring MVC architecture Configuration management Spring Boot annotations ( @RestController , @Service , @Bean , etc.) Database SQL fundamentals Basic SQL queries ( SELECT , INSERT , UPDATE , DELETE ) Joins and relationships Database design principles Optimizations, indexing, etc. Relational Databases (RDBMS) Microsoft SQL Server MySQL SQLite PostgreSQL API Development RESTful API concepts HTTP methods ( GET , POST , PUT , DELETE ) Request/response structure Status codes API testing with tools like Postman or curl Build Tools Maven Understanding pom.xml configuration Dependency management Building and packaging applications Maven lifecycle phases Development Tools Required Software For KwikPOS Live Development OpenJDK 8 java -version # Should show Java 8 Maven 3.6+ mvn -version MySQL 8.0 mysql --version Apache Tomcat 9.0 For KwikPOS API Development OpenJDK 17 java -version # Should show Java 17 Maven 3.8+ mvn -version Apache Tomcat 10.0 For Frontend Development (Angular) Node.js (LTS version recommended) node --version npm --version Angular CLI npm install -g @angular/cli ng version TypeScript npm install -g typescript tsc --version For Flutter Development Flutter SDK (latest stable version) flutter --version flutter doctor # Check installation Dart SDK (comes with Flutter) dart --version Android Studio or VS Code with Flutter/Dart plugins Android SDK (for Android development) Xcode (for iOS development, macOS only) Chrome or Edge (for web development) General Development Tools Git IDE: IntelliJ IDEA (recommended), Eclipse, or Visual Studio Code with Java Extensions API Testing: Postman or similar REST API testing tool Database Management: MySQL 8.0 CE Workbench ( MySQL ), DB Browser ( SQLite ), SQL Server Management Studio 19 ( MS SQL ), etc. Recommended IDE Setup IntelliJ IDEA Install Spring Boot plugin Configure Java SDK for each project (Java 8 for KwikPOS Live, Java 17 for KwikPOS API) Enable Maven auto-import Install Lombok plugin (if used in projects) Eclipse Install Spring Tools Suite (STS) Configure JDK versions Import as Maven projects VS Code (for Java) Install Extension Pack for Java Install Spring Boot Extension Pack Configure Java SDK paths Install Lombok Annotations Support for VS Code VS Code (for Angular) Install Angular Language Service extension Install Angular Snippets extension Install TSLint or ESLint extension Install Prettier for code formatting Configure TypeScript settings Android Studio (for Flutter) Install Flutter and Dart plugins Configure Flutter SDK path Set up Android emulator or connect physical device Enable Dart analysis VS Code (for Flutter) Install Flutter extension Install Dart extension Configure Flutter SDK path Set up debugging configurations Optional but Helpful Basic Linux/Unix commands - Helpful for server deployment and troubleshooting AWS familiarity - Understanding EC2, deployment concepts for KwikPOS Live Docker basics - May be useful for containerized development environments API documentation tools - Swagger/OpenAPI experience is a plus Verification Checklist Before proceeding to project setup, verify you have: For Backend Development (KwikPOS Live/API): Git installed and configured with your credentials Appropriate JDK version installed for your project Maven installed and accessible from command line MySQL & MS SQL Server installed (for KwikPOS Live development) IDE installed with Spring Boot support Basic understanding of Spring Boot and REST APIs Ability to clone repositories and create branches For Frontend Development (Angular): Git installed and configured with your credentials Node.js and npm installed Angular CLI installed globally TypeScript installed and configured IDE (VS Code recommended) with Angular extensions Basic understanding of Angular and TypeScript Familiarity with RxJS and HTTP client For Flutter Development: Git installed and configured with your credentials Flutter SDK installed and in PATH flutter doctor shows no critical issues IDE (Android Studio or VS Code) with Flutter/Dart plugins installed Android SDK installed (for Android development) Ability to run Flutter apps on emulator or device Basic understanding of Flutter widgets and state management Next Steps Once you've verified all prerequisites, proceed to: Getting Started - Overview of the KwikPOS ecosystem KwikPOS Live - Backend project documentation KwikPOS API - Kiosk adapter project documentation FullyBooked (WebExt) - Integration of KwikPOS & FullyBooked project documentation Getting Help If you need help with prerequisites: Tool Installation: Check official documentation for each tool Java/Spring Boot Concepts: Review Spring Boot official guides Flutter/Dart Concepts: Review Flutter official documentation at flutter.dev Git Questions: Consult Git documentation or your team lead Access Issues: Contact your team lead for repository credentials Flutter Setup Issues: Run flutter doctor -v for detailed diagnostics","title":"Prerequisites"},{"location":"prerequisites.html#required-knowledge","text":"","title":"Required Knowledge"},{"location":"prerequisites.html#version-control","text":"Git fundamentals Cloning repositories Creating and managing branches Committing and pushing changes Pull requests and code reviews Resolving merge conflicts Basic Git workflows (feature branches, main branch)","title":"Version Control"},{"location":"prerequisites.html#frontend-development-angular","text":"Node.js and npm package management TypeScript fundamentals Angular framework basics Components, templates, and data binding Services and dependency injection RxJS and Observables HTTP client and API integration Routing and navigation Angular forms and validation","title":"Frontend Development (Angular)"},{"location":"prerequisites.html#flutter-development","text":"Dart programming language fundamentals Flutter widget system and UI composition State management concepts (setState, Provider, Bloc, etc.) Asynchronous programming (Futures, Streams, async/await) Navigation and routing API integration and HTTP requests Local data persistence (SharedPreferences, SQLite) Flutter app lifecycle and debugging","title":"Flutter Development"},{"location":"prerequisites.html#java-development","text":"Core Java programming Object-oriented programming concepts Java collections and data structures Exception handling File I/O operations Multithreading basics","title":"Java Development"},{"location":"prerequisites.html#spring-boot-framework","text":"Spring Boot fundamentals Dependency injection and IoC containers REST API development Spring MVC architecture Configuration management Spring Boot annotations ( @RestController , @Service , @Bean , etc.)","title":"Spring Boot Framework"},{"location":"prerequisites.html#database","text":"SQL fundamentals Basic SQL queries ( SELECT , INSERT , UPDATE , DELETE ) Joins and relationships Database design principles Optimizations, indexing, etc. Relational Databases (RDBMS) Microsoft SQL Server MySQL SQLite PostgreSQL","title":"Database"},{"location":"prerequisites.html#api-development","text":"RESTful API concepts HTTP methods ( GET , POST , PUT , DELETE ) Request/response structure Status codes API testing with tools like Postman or curl","title":"API Development"},{"location":"prerequisites.html#build-tools","text":"Maven Understanding pom.xml configuration Dependency management Building and packaging applications Maven lifecycle phases","title":"Build Tools"},{"location":"prerequisites.html#development-tools","text":"","title":"Development Tools"},{"location":"prerequisites.html#required-software","text":"","title":"Required Software"},{"location":"prerequisites.html#for-kwikpos-live-development","text":"OpenJDK 8 java -version # Should show Java 8 Maven 3.6+ mvn -version MySQL 8.0 mysql --version Apache Tomcat 9.0","title":"For KwikPOS Live Development"},{"location":"prerequisites.html#for-kwikpos-api-development","text":"OpenJDK 17 java -version # Should show Java 17 Maven 3.8+ mvn -version Apache Tomcat 10.0","title":"For KwikPOS API Development"},{"location":"prerequisites.html#for-frontend-development-angular","text":"Node.js (LTS version recommended) node --version npm --version Angular CLI npm install -g @angular/cli ng version TypeScript npm install -g typescript tsc --version","title":"For Frontend Development (Angular)"},{"location":"prerequisites.html#for-flutter-development","text":"Flutter SDK (latest stable version) flutter --version flutter doctor # Check installation Dart SDK (comes with Flutter) dart --version Android Studio or VS Code with Flutter/Dart plugins Android SDK (for Android development) Xcode (for iOS development, macOS only) Chrome or Edge (for web development)","title":"For Flutter Development"},{"location":"prerequisites.html#general-development-tools","text":"Git IDE: IntelliJ IDEA (recommended), Eclipse, or Visual Studio Code with Java Extensions API Testing: Postman or similar REST API testing tool Database Management: MySQL 8.0 CE Workbench ( MySQL ), DB Browser ( SQLite ), SQL Server Management Studio 19 ( MS SQL ), etc.","title":"General Development Tools"},{"location":"prerequisites.html#recommended-ide-setup","text":"","title":"Recommended IDE Setup"},{"location":"prerequisites.html#intellij-idea","text":"Install Spring Boot plugin Configure Java SDK for each project (Java 8 for KwikPOS Live, Java 17 for KwikPOS API) Enable Maven auto-import Install Lombok plugin (if used in projects)","title":"IntelliJ IDEA"},{"location":"prerequisites.html#eclipse","text":"Install Spring Tools Suite (STS) Configure JDK versions Import as Maven projects","title":"Eclipse"},{"location":"prerequisites.html#vs-code-for-java","text":"Install Extension Pack for Java Install Spring Boot Extension Pack Configure Java SDK paths Install Lombok Annotations Support for VS Code","title":"VS Code (for Java)"},{"location":"prerequisites.html#vs-code-for-angular","text":"Install Angular Language Service extension Install Angular Snippets extension Install TSLint or ESLint extension Install Prettier for code formatting Configure TypeScript settings","title":"VS Code (for Angular)"},{"location":"prerequisites.html#android-studio-for-flutter","text":"Install Flutter and Dart plugins Configure Flutter SDK path Set up Android emulator or connect physical device Enable Dart analysis","title":"Android Studio (for Flutter)"},{"location":"prerequisites.html#vs-code-for-flutter","text":"Install Flutter extension Install Dart extension Configure Flutter SDK path Set up debugging configurations","title":"VS Code (for Flutter)"},{"location":"prerequisites.html#optional-but-helpful","text":"Basic Linux/Unix commands - Helpful for server deployment and troubleshooting AWS familiarity - Understanding EC2, deployment concepts for KwikPOS Live Docker basics - May be useful for containerized development environments API documentation tools - Swagger/OpenAPI experience is a plus","title":"Optional but Helpful"},{"location":"prerequisites.html#verification-checklist","text":"Before proceeding to project setup, verify you have: For Backend Development (KwikPOS Live/API): Git installed and configured with your credentials Appropriate JDK version installed for your project Maven installed and accessible from command line MySQL & MS SQL Server installed (for KwikPOS Live development) IDE installed with Spring Boot support Basic understanding of Spring Boot and REST APIs Ability to clone repositories and create branches For Frontend Development (Angular): Git installed and configured with your credentials Node.js and npm installed Angular CLI installed globally TypeScript installed and configured IDE (VS Code recommended) with Angular extensions Basic understanding of Angular and TypeScript Familiarity with RxJS and HTTP client For Flutter Development: Git installed and configured with your credentials Flutter SDK installed and in PATH flutter doctor shows no critical issues IDE (Android Studio or VS Code) with Flutter/Dart plugins installed Android SDK installed (for Android development) Ability to run Flutter apps on emulator or device Basic understanding of Flutter widgets and state management","title":"Verification Checklist"},{"location":"prerequisites.html#next-steps","text":"Once you've verified all prerequisites, proceed to: Getting Started - Overview of the KwikPOS ecosystem KwikPOS Live - Backend project documentation KwikPOS API - Kiosk adapter project documentation FullyBooked (WebExt) - Integration of KwikPOS & FullyBooked project documentation","title":"Next Steps"},{"location":"prerequisites.html#getting-help","text":"If you need help with prerequisites: Tool Installation: Check official documentation for each tool Java/Spring Boot Concepts: Review Spring Boot official guides Flutter/Dart Concepts: Review Flutter official documentation at flutter.dev Git Questions: Consult Git documentation or your team lead Access Issues: Contact your team lead for repository credentials Flutter Setup Issues: Run flutter doctor -v for detailed diagnostics","title":"Getting Help"},{"location":"project-files.html","text":"This page provides access to project turnover files stored in Google Drive. Shared Drive Location Project turnover files, including design assets, documentation, and configuration references, are available in the following read-only Google Drive folder: KwikPOS Project Files \u2192 What's Inside The shared drive contains: Design Files : UI/UX mockups, wireframes, and design specifications Configuration Templates : Sample environment files and configuration references Deployment Guides : Supplementary documentation for the how-to deploy the projects Documentation : Additional project documentation and specifications Assets : Images, logos, and other media resources Database Schemas : ER diagrams and database documentation Meeting Notes : Architecture decisions and planning documents Read-Only Access: These files are shared as view-only for reference purposes. If you need access or have any issues viewing the files, please contact the resource owner. Related Resources Getting Started - Initial setup and onboarding Prerequisites - Required tools and access","title":"Project Files"},{"location":"project-files.html#shared-drive-location","text":"Project turnover files, including design assets, documentation, and configuration references, are available in the following read-only Google Drive folder: KwikPOS Project Files \u2192","title":"Shared Drive Location"},{"location":"project-files.html#whats-inside","text":"The shared drive contains: Design Files : UI/UX mockups, wireframes, and design specifications Configuration Templates : Sample environment files and configuration references Deployment Guides : Supplementary documentation for the how-to deploy the projects Documentation : Additional project documentation and specifications Assets : Images, logos, and other media resources Database Schemas : ER diagrams and database documentation Meeting Notes : Architecture decisions and planning documents Read-Only Access: These files are shared as view-only for reference purposes. If you need access or have any issues viewing the files, please contact the resource owner.","title":"What's Inside"},{"location":"project-files.html#related-resources","text":"Getting Started - Initial setup and onboarding Prerequisites - Required tools and access","title":"Related Resources"},{"location":"status-code-reference.html","text":"This page documents the status codes used in sales records across different POS systems in the KwikPOS ecosystem. Overview Status codes are used to identify the type of transaction or operation recorded in the sales database. Different POS systems use different status code mappings, which is important to understand when working with sales data, reports, or integrations. Legacy POS (Chase) The following status codes are used in Chase POS sales records: Status Code Transaction Type 1 Regular Transaction 3 Post Void 4 Suspend 5 Regular Transaction (Failed to Print EJ / Timed Out During Transaction) 6 Change Fund 7 Cash Pickup 8 Tender Declaration 9 X-Read 10 Z-Read 11 Print Tempo 99 Refund 501 Spot Audit 502 X-Read (All Cashiers) Usage Notes Status Code 1 represents the most common transaction type - regular customer sales Status Code 5 indicates a regular transaction that encountered printing issues but was still completed Status Codes 9, 10, 502 are reporting operations (X-Read, Z-Read) Status Codes 6, 7, 8 are cash management operations Status Code 99 is used for customer refunds Status Codes 501 is for audit operations KwikPOS Pro The following status codes are used in KwikPOS Pro sales records: Status Code Transaction Type 1 Regular Transaction 2 Post Void Usage Notes KwikPOS Pro uses a simplified status code system compared to Chase POS Status Code 1 represents regular customer sales transactions Status Code 2 represents voided transactions Important Considerations When Working with Sales Data When querying or analyzing sales data across different POS systems: Be aware of the POS system in use - Different clients may be using different POS systems Filter appropriately - When calculating sales totals, you typically want to filter for regular transactions (Status Code 1) Exclude non-sales operations - Operations like X-Reads, Z-Reads, and cash management should be excluded from sales reports Handle voids correctly - Post voids (Status Code 3 in Chase POS, Status Code 2 in KwikPOS Pro) should be handled appropriately in calculations Code Examples Filtering Regular Transactions (Chase POS): -- Include only regular sales transactions SELECT * FROM posdb.dbo.SALES1 WHERE [status] IN (1, 5); -- Regular transactions including those with print issues Filtering Regular Transactions (KwikPOS Pro): -- Include only regular sales transactions SELECT * FROM sales_m2 WHERE \"status\" = 1; -- Regular transactions only Excluding Non-Sales Operations (Chase POS): -- Exclude reporting and cash management operations SELECT * FROM posdb.dbo.SALES1 WHERE [status] NOT IN (6, 7, 8, 9, 10, 11, 501, 502); Cross-System Compatibility When building features that work across both Chase POS and KwikPOS Pro: Regular Transactions: Status Code 1 is consistent across both systems Voided Transactions: Chase POS uses 3, KwikPOS Pro uses 2 System-Specific Codes: Be aware that Chase POS has many operation types that don't exist in KwikPOS Pro Related Documentation KwikPOS Live Overview - Backend system documentation KwikPOS API Overview - Kiosk adapter documentation FullyBooked (WebExt) - Integration of KwikPOS & FullyBooked documentation Note: This reference is maintained based on production systems as of the last update date. If you notice discrepancies or new status codes, please update this documentation and notify the development team.","title":"Status Code Reference"},{"location":"status-code-reference.html#overview","text":"Status codes are used to identify the type of transaction or operation recorded in the sales database. Different POS systems use different status code mappings, which is important to understand when working with sales data, reports, or integrations.","title":"Overview"},{"location":"status-code-reference.html#legacy-pos-chase","text":"The following status codes are used in Chase POS sales records: Status Code Transaction Type 1 Regular Transaction 3 Post Void 4 Suspend 5 Regular Transaction (Failed to Print EJ / Timed Out During Transaction) 6 Change Fund 7 Cash Pickup 8 Tender Declaration 9 X-Read 10 Z-Read 11 Print Tempo 99 Refund 501 Spot Audit 502 X-Read (All Cashiers)","title":"Legacy POS (Chase)"},{"location":"status-code-reference.html#usage-notes","text":"Status Code 1 represents the most common transaction type - regular customer sales Status Code 5 indicates a regular transaction that encountered printing issues but was still completed Status Codes 9, 10, 502 are reporting operations (X-Read, Z-Read) Status Codes 6, 7, 8 are cash management operations Status Code 99 is used for customer refunds Status Codes 501 is for audit operations","title":"Usage Notes"},{"location":"status-code-reference.html#kwikpos-pro","text":"The following status codes are used in KwikPOS Pro sales records: Status Code Transaction Type 1 Regular Transaction 2 Post Void","title":"KwikPOS Pro"},{"location":"status-code-reference.html#usage-notes_1","text":"KwikPOS Pro uses a simplified status code system compared to Chase POS Status Code 1 represents regular customer sales transactions Status Code 2 represents voided transactions","title":"Usage Notes"},{"location":"status-code-reference.html#important-considerations","text":"","title":"Important Considerations"},{"location":"status-code-reference.html#when-working-with-sales-data","text":"When querying or analyzing sales data across different POS systems: Be aware of the POS system in use - Different clients may be using different POS systems Filter appropriately - When calculating sales totals, you typically want to filter for regular transactions (Status Code 1) Exclude non-sales operations - Operations like X-Reads, Z-Reads, and cash management should be excluded from sales reports Handle voids correctly - Post voids (Status Code 3 in Chase POS, Status Code 2 in KwikPOS Pro) should be handled appropriately in calculations","title":"When Working with Sales Data"},{"location":"status-code-reference.html#code-examples","text":"Filtering Regular Transactions (Chase POS): -- Include only regular sales transactions SELECT * FROM posdb.dbo.SALES1 WHERE [status] IN (1, 5); -- Regular transactions including those with print issues Filtering Regular Transactions (KwikPOS Pro): -- Include only regular sales transactions SELECT * FROM sales_m2 WHERE \"status\" = 1; -- Regular transactions only Excluding Non-Sales Operations (Chase POS): -- Exclude reporting and cash management operations SELECT * FROM posdb.dbo.SALES1 WHERE [status] NOT IN (6, 7, 8, 9, 10, 11, 501, 502);","title":"Code Examples"},{"location":"status-code-reference.html#cross-system-compatibility","text":"When building features that work across both Chase POS and KwikPOS Pro: Regular Transactions: Status Code 1 is consistent across both systems Voided Transactions: Chase POS uses 3, KwikPOS Pro uses 2 System-Specific Codes: Be aware that Chase POS has many operation types that don't exist in KwikPOS Pro","title":"Cross-System Compatibility"},{"location":"status-code-reference.html#related-documentation","text":"KwikPOS Live Overview - Backend system documentation KwikPOS API Overview - Kiosk adapter documentation FullyBooked (WebExt) - Integration of KwikPOS & FullyBooked documentation Note: This reference is maintained based on production systems as of the last update date. If you notice discrepancies or new status codes, please update this documentation and notify the development team.","title":"Related Documentation"},{"location":"projects/kwikpos-api/index.html","text":"Purpose: Bridge layer connecting self-ordering kiosks to legacy POS applications KwikPOS API serves as an on-premise adapter that enables modern self-ordering kiosks to communicate seamlessly with legacy POS applications, particularly Chase POS, without requiring modifications to the existing POS software. Tech Stack Framework: Spring Boot 3.5.4 Runtime: Java 17 Deployment: Apache Tomcat 10.0 Deployment Location: On-premise POS machine Database Configuration Database Schemas KwikPOS API connects to the following database schemas used by the legacy POS application: posdb - Primary database schema for POS operations orderdb - Database schema for order management These schemas are part of the legacy POS application's database structure and are accessed by the API adapter to facilitate communication between modern kiosks and the legacy POS system. Key Tables for Order Processing The API primarily writes to the following tables in the orderdb schema when processing orders from kiosks: dbo.SALESORDER Purpose: Stores order header information Key Data: Order reference number, customer details, order timestamp, total amount, order status Usage: Each order from a kiosk creates a new record in this table with a unique order reference number Order Statuses: \"PENDING\" - Initial status when order is just sent in from the kiosk This is the status the POS looks up to identify new orders waiting to be retrieved by the cashier Orders remain in this status until the cashier retrieves them at the counter Auto-Cleanup: Pending orders that exceed 1 hour are automatically deleted Use Case: When customers send in an order and select \"pay via cash\" but don't arrive at the counter to complete payment \"RETRIEVED\" - Order has been fulfilled and completed Set when the order sent by the kiosk to the POS has been retrieved by the cashier Indicates the customer has paid and the order has been fulfilled Final status for completed orders dbo.SALESORDER_ITEM Purpose: Stores individual items within an order Key Data: Item details, quantity, price, modifiers, linked to order reference number Usage: Multiple records created per order - one for each item ordered Relationship: Links to dbo.SALESORDER via order reference number dbo.SALESORDER_PAYMENT Purpose: Stores payment information for cashless orders Key Data: Payment method, amount, transaction details, payment status Usage: Currently not in active use - Reserved for future cashless payment integration Status: Payment integration with legacy POS requires additional modifications on the POS side (auto-print, event execution) which are not yet implemented Note: Only applicable for 'CASHLESS' order types where payment is processed on the self-ordering kiosk Important: As of the current implementation, only dbo.SALESORDER and dbo.SALESORDER_ITEM are actively used. The dbo.SALESORDER_PAYMENT table exists but is not utilized until cashless payment integration is completed on the legacy POS application. Database Sequences dbo.REG_SO_SEQ Purpose: Sequence generator for sales order reference numbers Usage: Generates unique, sequential order reference numbers for orders from kiosks Naming Convention: \"REG\" prefix indicates regular/standard kiosk orders Future Considerations: The naming pattern allows for potential addition of separate sequences for different order sources (e.g., Grab Food , Food Panda ) if needed in the future, though this is not currently implemented System Architecture The following sequence diagram illustrates how the KwikPOS API processes orders from kiosks to the legacy POS system: Key Features Kiosk Integration API server for self-ordering kiosk integration Real-time order transmission from kiosks to POS terminals Support for modern kiosk interfaces Data Transformation Data transformation layer between modern kiosks and legacy POS systems Format conversion and data mapping Protocol adaptation Legacy POS Compatibility Compatibility layer for Chase POS integration Direct integration with legacy POS applications Local Server Runs as local server on POS machine Handles requests from nearby kiosks Low-latency local network communication Main Highlight This adapter enables our modern self-ordering kiosk products to seamlessly communicate with legacy POS applications, particularly Chase POS, and possibly other POS applications if requested. This is the key value proposition: Modern kiosk interface maintained Seamless integration Minimal disruption to existing operations Quick Links Responsibilities - Core system responsibilities Deployment Architecture - Infrastructure and deployment details Development Setup - Local environment configuration Project Structure - Code organization and architecture Development Tasks - Common development workflows Testing - Testing strategies and practices Architecture Considerations - Design principles and patterns Troubleshooting - Common issues and solutions Roadmap & Planned Work - Future features and integrations Getting Help If you encounter issues: Technical Questions: Reach out to the development team, or you may contact the original author of the codebase via email ( adrnmlgrto.dev@gmail.com ) Integration Issues: Consult with technical support or helpdesk Deployment Problems: Contact on-site technical support or helpdesk Architecture Questions: Review adapter patterns or consult senior developers Kiosk Issues: Check with KwikPOS Pro development team","title":"Overview"},{"location":"projects/kwikpos-api/index.html#tech-stack","text":"Framework: Spring Boot 3.5.4 Runtime: Java 17 Deployment: Apache Tomcat 10.0 Deployment Location: On-premise POS machine","title":"Tech Stack"},{"location":"projects/kwikpos-api/index.html#database-configuration","text":"","title":"Database Configuration"},{"location":"projects/kwikpos-api/index.html#database-schemas","text":"KwikPOS API connects to the following database schemas used by the legacy POS application: posdb - Primary database schema for POS operations orderdb - Database schema for order management These schemas are part of the legacy POS application's database structure and are accessed by the API adapter to facilitate communication between modern kiosks and the legacy POS system.","title":"Database Schemas"},{"location":"projects/kwikpos-api/index.html#key-tables-for-order-processing","text":"The API primarily writes to the following tables in the orderdb schema when processing orders from kiosks:","title":"Key Tables for Order Processing"},{"location":"projects/kwikpos-api/index.html#dbosalesorder","text":"Purpose: Stores order header information Key Data: Order reference number, customer details, order timestamp, total amount, order status Usage: Each order from a kiosk creates a new record in this table with a unique order reference number Order Statuses: \"PENDING\" - Initial status when order is just sent in from the kiosk This is the status the POS looks up to identify new orders waiting to be retrieved by the cashier Orders remain in this status until the cashier retrieves them at the counter Auto-Cleanup: Pending orders that exceed 1 hour are automatically deleted Use Case: When customers send in an order and select \"pay via cash\" but don't arrive at the counter to complete payment \"RETRIEVED\" - Order has been fulfilled and completed Set when the order sent by the kiosk to the POS has been retrieved by the cashier Indicates the customer has paid and the order has been fulfilled Final status for completed orders","title":"dbo.SALESORDER"},{"location":"projects/kwikpos-api/index.html#dbosalesorder_item","text":"Purpose: Stores individual items within an order Key Data: Item details, quantity, price, modifiers, linked to order reference number Usage: Multiple records created per order - one for each item ordered Relationship: Links to dbo.SALESORDER via order reference number","title":"dbo.SALESORDER_ITEM"},{"location":"projects/kwikpos-api/index.html#dbosalesorder_payment","text":"Purpose: Stores payment information for cashless orders Key Data: Payment method, amount, transaction details, payment status Usage: Currently not in active use - Reserved for future cashless payment integration Status: Payment integration with legacy POS requires additional modifications on the POS side (auto-print, event execution) which are not yet implemented Note: Only applicable for 'CASHLESS' order types where payment is processed on the self-ordering kiosk Important: As of the current implementation, only dbo.SALESORDER and dbo.SALESORDER_ITEM are actively used. The dbo.SALESORDER_PAYMENT table exists but is not utilized until cashless payment integration is completed on the legacy POS application.","title":"dbo.SALESORDER_PAYMENT"},{"location":"projects/kwikpos-api/index.html#database-sequences","text":"","title":"Database Sequences"},{"location":"projects/kwikpos-api/index.html#dboreg_so_seq","text":"Purpose: Sequence generator for sales order reference numbers Usage: Generates unique, sequential order reference numbers for orders from kiosks Naming Convention: \"REG\" prefix indicates regular/standard kiosk orders Future Considerations: The naming pattern allows for potential addition of separate sequences for different order sources (e.g., Grab Food , Food Panda ) if needed in the future, though this is not currently implemented","title":"dbo.REG_SO_SEQ"},{"location":"projects/kwikpos-api/index.html#system-architecture","text":"The following sequence diagram illustrates how the KwikPOS API processes orders from kiosks to the legacy POS system:","title":"System Architecture"},{"location":"projects/kwikpos-api/index.html#key-features","text":"","title":"Key Features"},{"location":"projects/kwikpos-api/index.html#kiosk-integration","text":"API server for self-ordering kiosk integration Real-time order transmission from kiosks to POS terminals Support for modern kiosk interfaces","title":"Kiosk Integration"},{"location":"projects/kwikpos-api/index.html#data-transformation","text":"Data transformation layer between modern kiosks and legacy POS systems Format conversion and data mapping Protocol adaptation","title":"Data Transformation"},{"location":"projects/kwikpos-api/index.html#legacy-pos-compatibility","text":"Compatibility layer for Chase POS integration Direct integration with legacy POS applications","title":"Legacy POS Compatibility"},{"location":"projects/kwikpos-api/index.html#local-server","text":"Runs as local server on POS machine Handles requests from nearby kiosks Low-latency local network communication","title":"Local Server"},{"location":"projects/kwikpos-api/index.html#main-highlight","text":"This adapter enables our modern self-ordering kiosk products to seamlessly communicate with legacy POS applications, particularly Chase POS, and possibly other POS applications if requested. This is the key value proposition: Modern kiosk interface maintained Seamless integration Minimal disruption to existing operations","title":"Main Highlight"},{"location":"projects/kwikpos-api/index.html#quick-links","text":"Responsibilities - Core system responsibilities Deployment Architecture - Infrastructure and deployment details Development Setup - Local environment configuration Project Structure - Code organization and architecture Development Tasks - Common development workflows Testing - Testing strategies and practices Architecture Considerations - Design principles and patterns Troubleshooting - Common issues and solutions Roadmap & Planned Work - Future features and integrations","title":"Quick Links"},{"location":"projects/kwikpos-api/index.html#getting-help","text":"If you encounter issues: Technical Questions: Reach out to the development team, or you may contact the original author of the codebase via email ( adrnmlgrto.dev@gmail.com ) Integration Issues: Consult with technical support or helpdesk Deployment Problems: Contact on-site technical support or helpdesk Architecture Questions: Review adapter patterns or consult senior developers Kiosk Issues: Check with KwikPOS Pro development team","title":"Getting Help"},{"location":"projects/kwikpos-api/architecture.html","text":"Stateless Design Each request is independent No session persistence required Horizontal scaling possible if needed Error Handling Robust error handling for POS failures Retry mechanisms for transient errors Clear error messages to kiosks Performance Low-latency requirements Efficient data transformation Minimal processing overhead Security Local network security Input validation Secure POS communication Design Principles Adapter Pattern The system uses the adapter pattern to bridge modern and legacy systems without modifying either. Separation of Concerns Clear separation between: Kiosk communication layer Data transformation layer POS integration layer Fault Tolerance Graceful degradation when POS is unavailable Retry logic for transient failures Comprehensive error logging","title":"Architecture Considerations"},{"location":"projects/kwikpos-api/architecture.html#stateless-design","text":"Each request is independent No session persistence required Horizontal scaling possible if needed","title":"Stateless Design"},{"location":"projects/kwikpos-api/architecture.html#error-handling","text":"Robust error handling for POS failures Retry mechanisms for transient errors Clear error messages to kiosks","title":"Error Handling"},{"location":"projects/kwikpos-api/architecture.html#performance","text":"Low-latency requirements Efficient data transformation Minimal processing overhead","title":"Performance"},{"location":"projects/kwikpos-api/architecture.html#security","text":"Local network security Input validation Secure POS communication","title":"Security"},{"location":"projects/kwikpos-api/architecture.html#design-principles","text":"","title":"Design Principles"},{"location":"projects/kwikpos-api/architecture.html#adapter-pattern","text":"The system uses the adapter pattern to bridge modern and legacy systems without modifying either.","title":"Adapter Pattern"},{"location":"projects/kwikpos-api/architecture.html#separation-of-concerns","text":"Clear separation between: Kiosk communication layer Data transformation layer POS integration layer","title":"Separation of Concerns"},{"location":"projects/kwikpos-api/architecture.html#fault-tolerance","text":"Graceful degradation when POS is unavailable Retry logic for transient failures Comprehensive error logging","title":"Fault Tolerance"},{"location":"projects/kwikpos-api/deployment.html","text":"Infrastructure Location: Installed on individual POS machines acting as local servers Application Server: Apache Tomcat 10.0 servlet container Network: Local network access for nearby kiosks Integration: Direct connection with Chase POS application Database: Direct MS SQL Server database connection Deployment Characteristics Scope: Single store deployment Isolation: Each installation serves one POS terminal Network: Local LAN communication ( 0.0.0.0 ) Availability: Must be running whenever kiosks are operational Note: You can view this folder for reference with the deployment implementation Configuration POS machine-specific settings Kiosk connection parameters Legacy POS integration settings Network and security configuration","title":"Deployment Architecture"},{"location":"projects/kwikpos-api/deployment.html#infrastructure","text":"Location: Installed on individual POS machines acting as local servers Application Server: Apache Tomcat 10.0 servlet container Network: Local network access for nearby kiosks Integration: Direct connection with Chase POS application Database: Direct MS SQL Server database connection","title":"Infrastructure"},{"location":"projects/kwikpos-api/deployment.html#deployment-characteristics","text":"Scope: Single store deployment Isolation: Each installation serves one POS terminal Network: Local LAN communication ( 0.0.0.0 ) Availability: Must be running whenever kiosks are operational Note: You can view this folder for reference with the deployment implementation","title":"Deployment Characteristics"},{"location":"projects/kwikpos-api/deployment.html#configuration","text":"POS machine-specific settings Kiosk connection parameters Legacy POS integration settings Network and security configuration","title":"Configuration"},{"location":"projects/kwikpos-api/development.html","text":"Adding New Kiosk Features Create feature branch from main Implement endpoint in controller Add transformation logic if needed Test with mock kiosk requests Submit pull request for code review Enhancing POS Integration Identify required POS functionality Implement adapter logic Add transformation for new data types Test with actual POS system if available Document integration details Testing Integration Mock kiosk requests using Postman Test data transformation accuracy Verify POS communication (if test system available) Check error handling scenarios Best Practices Follow existing transformation patterns Maintain clear separation between kiosk and POS data models Document any POS-specific quirks or requirements Test with realistic order scenarios Handle edge cases gracefully","title":"Development Tasks"},{"location":"projects/kwikpos-api/development.html#adding-new-kiosk-features","text":"Create feature branch from main Implement endpoint in controller Add transformation logic if needed Test with mock kiosk requests Submit pull request for code review","title":"Adding New Kiosk Features"},{"location":"projects/kwikpos-api/development.html#enhancing-pos-integration","text":"Identify required POS functionality Implement adapter logic Add transformation for new data types Test with actual POS system if available Document integration details","title":"Enhancing POS Integration"},{"location":"projects/kwikpos-api/development.html#testing-integration","text":"Mock kiosk requests using Postman Test data transformation accuracy Verify POS communication (if test system available) Check error handling scenarios","title":"Testing Integration"},{"location":"projects/kwikpos-api/development.html#best-practices","text":"Follow existing transformation patterns Maintain clear separation between kiosk and POS data models Document any POS-specific quirks or requirements Test with realistic order scenarios Handle edge cases gracefully","title":"Best Practices"},{"location":"projects/kwikpos-api/responsibilities.html","text":"Order Reception Receives order requests from self-ordering kiosks Validates incoming order data Handles multiple concurrent kiosk connections Data Transformation Transforms order data from modern format to legacy POS format Maps fields and data structures Ensures data compatibility POS Communication Transmits orders to the connected POS terminal Handles POS-specific protocols Manages error responses and retries Bridge Layer Serves as the communication bridge between modern ordering interfaces and legacy systems Maintains session state Provides logging and monitoring","title":"Responsibilities"},{"location":"projects/kwikpos-api/responsibilities.html#order-reception","text":"Receives order requests from self-ordering kiosks Validates incoming order data Handles multiple concurrent kiosk connections","title":"Order Reception"},{"location":"projects/kwikpos-api/responsibilities.html#data-transformation","text":"Transforms order data from modern format to legacy POS format Maps fields and data structures Ensures data compatibility","title":"Data Transformation"},{"location":"projects/kwikpos-api/responsibilities.html#pos-communication","text":"Transmits orders to the connected POS terminal Handles POS-specific protocols Manages error responses and retries","title":"POS Communication"},{"location":"projects/kwikpos-api/responsibilities.html#bridge-layer","text":"Serves as the communication bridge between modern ordering interfaces and legacy systems Maintains session state Provides logging and monitoring","title":"Bridge Layer"},{"location":"projects/kwikpos-api/roadmap.html","text":"This document outlines planned features, integrations, and improvements for KwikPOS API. These items represent future work that needs to be implemented. Planned Features KwikPOS Terminal (Fine-Dine Handheld Device) Support Priority: High Status: Planned Description: Modify or extend this project to support KwikPOS Terminal, a handheld ordering device for waiters in fine-dining restaurant setups. While technically still functioning as a kiosk-like ordering device, it's designed for waiter-assisted table ordering rather than self-service. Product Context: KwikPOS Terminal is in the current product lineup Used in fine-dining restaurant environments where waiters take orders at individual tables Handheld device (likely tablet-based) that connects to the POS system Similar data flow to kiosks but different UX and use case User Stories: As a waiter, I want to take table orders on a handheld device so that I can capture orders directly at the table As a restaurant manager, I want orders from terminals to sync with the POS so that kitchen can receive them immediately As a waiter, I want to assign orders to specific table numbers so that we can track which orders belong to which tables Technical Approach: Evaluate whether to extend current KwikPOS API or create a separate terminal-specific adapter Implement table management functionality (table numbers, table status) Add support for order assignment to tables and waiters Consider authentication/authorization for individual waiter accounts Implement order modification flows (add items, remove items, split bills) Support for dine-in specific features (course sequencing, special requests) Key Differences from Self-Service Kiosks: Table number assignment required Waiter identification/tracking needed More complex order modification workflows May need split billing support Course/timing management (appetizers, mains, desserts) Special dietary requests and customizations Acceptance Criteria: Terminal devices can authenticate and connect to POS Orders can be assigned to specific tables Waiter identification is captured with orders Order modifications are supported Integration with existing Chase POS works seamlessly Table status tracking (occupied, available, reserved) Performance is acceptable for restaurant peak hours Resources: Product specs for KwikPOS Terminal (to be provided) UX/UI designs for terminal interface Requirements gathering with operations team Notes: Coordinate with KwikPOS Terminal product team for specific requirements Consider whether this should be a separate project or extension of current API May need to handle different network configurations (Wi-Fi for mobile devices) POS System Compatibility Integration with Other POS Providers Priority: Medium Status: Planned Description: Support integration with POS systems beyond Chase POS to enable selling KwikPOS kiosk products to clients who want to use their existing POS provider without switching systems. This expands the market reach for standalone kiosk sales. Current Support: Chase POS only Planned Support: Multiple POS providers (TBD based on sales requirements) Business Context: Enables selling kiosk products independently without requiring clients to switch their entire POS system Allows clients to keep their current POS provider while adding modern kiosk ordering capabilities Expands addressable market for kiosk-only sales No definite timeline yet, but likely to be requested once sales team starts selling kiosks independently Integration Requirements: POS system API documentation or database schema access Understanding of POS system's data models for menu items, orders, and transactions Network connectivity requirements between kiosk and POS Authentication/authorization mechanisms for the target POS system Transaction handling and error recovery patterns specific to each POS Technical Challenges: Each POS system has different data structures and APIs May require custom transformation logic for each POS provider Different authentication/security models across POS systems Varying levels of API maturity and documentation quality Testing complexity with multiple POS environments Maintaining backward compatibility with Chase POS while adding new providers Implementation Approach: Design an abstraction layer to support multiple POS providers Create a plugin/adapter pattern for each POS system Implement a configuration system to specify which POS provider is being used Build transformation layers specific to each POS provider's data format Develop comprehensive testing framework for multi-POS support Document integration requirements for each supported POS system Testing Plan: Test order flow end-to-end with each POS provider Verify data transformation accuracy for menu items and orders Test error scenarios (POS offline, network issues, timeout handling) Validate concurrent order handling from multiple kiosks Performance testing under load for each POS provider Security and authentication testing Regression testing to ensure Chase POS integration remains stable Notes: This will be triggered by sales team requirements - no specific timeline yet Priority and specific POS providers will be determined based on client demands Consider creating a priority list of POS systems based on market research Data Transformation Enhancements Calorie Count (kcal) Inclusion in Items Endpoint Response Priority: High Status: In Progress Description: Add calorie count information to the items endpoint response to comply with Quezon City Local Government Unit (LGU) Ordinance No. SP-3254 S-2024 , which requires food establishments to display calorie information on all menus including electronic/digital menus such as kiosks. Regulatory Context: Quezon City Calorie Labeling Ordinance ( SP-3254 S-2024 ) mandates restaurants and food businesses to include calorie counts (in kcal ) per serving on all menus, including: Printed menus Digital/electronic menus (including kiosks) Menu boards Implementation Timeline per Ordinance: Phase 1 (Dec 20, 2025): Food chains with 5 or more branches within Quezon City Phase 2 (2026): Businesses with 2 or more branches, plus hotels Phase 3 (2027): All food businesses (with some exemptions for micro-enterprises) Current Behavior: Items endpoint returns menu items without calorie information. The POS database has a column for calorie count, and now it returns it successfully, and the only remaining thing to do are validations and testing Planned Enhancement: Locate and identify the calorie count column in the POS database schema Add calorie count field to the item DTO (Data Transfer Object) Update SQL queries in mapper to include calorie column Include calories field in API response Ensure proper data type handling (integer or decimal) Handle null/missing calorie values gracefully Current Progress: Initial investigation started - identifying calorie column in POS database Column mapping and SQL query updates already done Still needs: Testing, validation, and deployment Implementation Details: Database column identified: [posdb].[dbo].[ITEMS].[calories] Response field name: calories (standardize naming) Handle cases where calorie data is not available (null handling) Unit of measurement: kilocalories ( kcal ) per serving Data type: Integer or Decimal or Double (verify with POS database schema) Testing Requirements: Verify calorie data is correctly retrieved from POS database Confirm response format matches kiosk frontend expectations Test with items that have calorie data Test with items that don't have calorie data (null handling) Validate data accuracy against known menu items Performance testing to ensure no significant impact on response time Integration testing with kiosk application Acceptance Criteria: Items endpoint includes calorie count in response Calorie value matches POS database value Null/missing values are handled gracefully API documentation updated to reflect new field Kiosk frontend can display calorie information correctly No breaking changes to existing API consumers Resources: Quezon City Ordinance SP-3254 S-2024 QC Calorie Labeling IRR PNA Article on QC Guidelines PhilStar: How QC's rule will change menus Notes: IMPORTANT: Work on this has already been started and is partially complete Next developer needs to validate, confirm, and test the implementation Coordinate with kiosk frontend team to ensure proper display of calorie information This is a compliance requirement with legal deadlines - prioritize accordingly May need to work with clients to ensure their menu items have calorie data populated in POS Consider adding API versioning if this is a breaking change Next Steps: Validate the database column mapping is correct Update DTOs to include calorie field Test thoroughly with real POS data Update API documentation Coordinate with frontend team for kiosk UI updates Plan deployment timeline to meet Phase 1 deadline (Dec 20, 2025) Notes for Future Developers General Context This project was personally started by myself, and its currently what I would call a \"good\" and flexible project that can adapt to requirement changes. Technically, this started to allow backwards compatibility with our modern self-ordering kiosk products to send orders to existing clients with their legacy POS devices. Do note that it might be updated in the future where you would need to integrate other POS provider's applications to allow our own products to still be sold. On-Premise Deployment Considerations The setting up and deployment would technically be handled by the helpdesk support teams. Do coordinate with them for these kinds of deployments with clients. Key Contacts Helpdesk Support: Tyrese Things to Keep in Mind Always confirm the modifications whether if it would be possible for us to do, or the change would be on the POS side. Always update the team lead or the project manager if the modifications requested after deployment needs to be billed or charged before implementing. Timeline & Prioritization Q4 2025 / Q1 2026 (Immediate Priority) Calorie Count Implementation - MUST complete before Phase 1 deadline (Dec 20, 2025) Complete database column mapping validation Finalize SQL query updates Testing and validation Deployment to individual client store branches with KwikPOS API 2026 (As Needed) KwikPOS Terminal Support - Timeline TBD based on product launch schedule Requirements gathering and technical design Implementation of table management features Waiter authentication and order assignment Testing with actual terminal devices Future (No Specific Timeline) Multi-POS Provider Support - Will be triggered by sales team requirements Determine which POS systems to support based on client demand Design abstraction layer for multi-POS compatibility Implement adapters for priority POS systems Testing and validation with each POS provider Ongoing Bug fixes and technical improvements as identified Performance optimizations Security updates and patches","title":"Roadmap & Planned Work"},{"location":"projects/kwikpos-api/roadmap.html#planned-features","text":"","title":"Planned Features"},{"location":"projects/kwikpos-api/roadmap.html#kwikpos-terminal-fine-dine-handheld-device-support","text":"Priority: High Status: Planned Description: Modify or extend this project to support KwikPOS Terminal, a handheld ordering device for waiters in fine-dining restaurant setups. While technically still functioning as a kiosk-like ordering device, it's designed for waiter-assisted table ordering rather than self-service. Product Context: KwikPOS Terminal is in the current product lineup Used in fine-dining restaurant environments where waiters take orders at individual tables Handheld device (likely tablet-based) that connects to the POS system Similar data flow to kiosks but different UX and use case User Stories: As a waiter, I want to take table orders on a handheld device so that I can capture orders directly at the table As a restaurant manager, I want orders from terminals to sync with the POS so that kitchen can receive them immediately As a waiter, I want to assign orders to specific table numbers so that we can track which orders belong to which tables Technical Approach: Evaluate whether to extend current KwikPOS API or create a separate terminal-specific adapter Implement table management functionality (table numbers, table status) Add support for order assignment to tables and waiters Consider authentication/authorization for individual waiter accounts Implement order modification flows (add items, remove items, split bills) Support for dine-in specific features (course sequencing, special requests) Key Differences from Self-Service Kiosks: Table number assignment required Waiter identification/tracking needed More complex order modification workflows May need split billing support Course/timing management (appetizers, mains, desserts) Special dietary requests and customizations Acceptance Criteria: Terminal devices can authenticate and connect to POS Orders can be assigned to specific tables Waiter identification is captured with orders Order modifications are supported Integration with existing Chase POS works seamlessly Table status tracking (occupied, available, reserved) Performance is acceptable for restaurant peak hours Resources: Product specs for KwikPOS Terminal (to be provided) UX/UI designs for terminal interface Requirements gathering with operations team Notes: Coordinate with KwikPOS Terminal product team for specific requirements Consider whether this should be a separate project or extension of current API May need to handle different network configurations (Wi-Fi for mobile devices)","title":"KwikPOS Terminal (Fine-Dine Handheld Device) Support"},{"location":"projects/kwikpos-api/roadmap.html#pos-system-compatibility","text":"","title":"POS System Compatibility"},{"location":"projects/kwikpos-api/roadmap.html#integration-with-other-pos-providers","text":"Priority: Medium Status: Planned Description: Support integration with POS systems beyond Chase POS to enable selling KwikPOS kiosk products to clients who want to use their existing POS provider without switching systems. This expands the market reach for standalone kiosk sales. Current Support: Chase POS only Planned Support: Multiple POS providers (TBD based on sales requirements) Business Context: Enables selling kiosk products independently without requiring clients to switch their entire POS system Allows clients to keep their current POS provider while adding modern kiosk ordering capabilities Expands addressable market for kiosk-only sales No definite timeline yet, but likely to be requested once sales team starts selling kiosks independently Integration Requirements: POS system API documentation or database schema access Understanding of POS system's data models for menu items, orders, and transactions Network connectivity requirements between kiosk and POS Authentication/authorization mechanisms for the target POS system Transaction handling and error recovery patterns specific to each POS Technical Challenges: Each POS system has different data structures and APIs May require custom transformation logic for each POS provider Different authentication/security models across POS systems Varying levels of API maturity and documentation quality Testing complexity with multiple POS environments Maintaining backward compatibility with Chase POS while adding new providers Implementation Approach: Design an abstraction layer to support multiple POS providers Create a plugin/adapter pattern for each POS system Implement a configuration system to specify which POS provider is being used Build transformation layers specific to each POS provider's data format Develop comprehensive testing framework for multi-POS support Document integration requirements for each supported POS system Testing Plan: Test order flow end-to-end with each POS provider Verify data transformation accuracy for menu items and orders Test error scenarios (POS offline, network issues, timeout handling) Validate concurrent order handling from multiple kiosks Performance testing under load for each POS provider Security and authentication testing Regression testing to ensure Chase POS integration remains stable Notes: This will be triggered by sales team requirements - no specific timeline yet Priority and specific POS providers will be determined based on client demands Consider creating a priority list of POS systems based on market research","title":"Integration with Other POS Providers"},{"location":"projects/kwikpos-api/roadmap.html#data-transformation-enhancements","text":"","title":"Data Transformation Enhancements"},{"location":"projects/kwikpos-api/roadmap.html#calorie-count-kcal-inclusion-in-items-endpoint-response","text":"Priority: High Status: In Progress Description: Add calorie count information to the items endpoint response to comply with Quezon City Local Government Unit (LGU) Ordinance No. SP-3254 S-2024 , which requires food establishments to display calorie information on all menus including electronic/digital menus such as kiosks. Regulatory Context: Quezon City Calorie Labeling Ordinance ( SP-3254 S-2024 ) mandates restaurants and food businesses to include calorie counts (in kcal ) per serving on all menus, including: Printed menus Digital/electronic menus (including kiosks) Menu boards Implementation Timeline per Ordinance: Phase 1 (Dec 20, 2025): Food chains with 5 or more branches within Quezon City Phase 2 (2026): Businesses with 2 or more branches, plus hotels Phase 3 (2027): All food businesses (with some exemptions for micro-enterprises) Current Behavior: Items endpoint returns menu items without calorie information. The POS database has a column for calorie count, and now it returns it successfully, and the only remaining thing to do are validations and testing Planned Enhancement: Locate and identify the calorie count column in the POS database schema Add calorie count field to the item DTO (Data Transfer Object) Update SQL queries in mapper to include calorie column Include calories field in API response Ensure proper data type handling (integer or decimal) Handle null/missing calorie values gracefully Current Progress: Initial investigation started - identifying calorie column in POS database Column mapping and SQL query updates already done Still needs: Testing, validation, and deployment Implementation Details: Database column identified: [posdb].[dbo].[ITEMS].[calories] Response field name: calories (standardize naming) Handle cases where calorie data is not available (null handling) Unit of measurement: kilocalories ( kcal ) per serving Data type: Integer or Decimal or Double (verify with POS database schema) Testing Requirements: Verify calorie data is correctly retrieved from POS database Confirm response format matches kiosk frontend expectations Test with items that have calorie data Test with items that don't have calorie data (null handling) Validate data accuracy against known menu items Performance testing to ensure no significant impact on response time Integration testing with kiosk application Acceptance Criteria: Items endpoint includes calorie count in response Calorie value matches POS database value Null/missing values are handled gracefully API documentation updated to reflect new field Kiosk frontend can display calorie information correctly No breaking changes to existing API consumers Resources: Quezon City Ordinance SP-3254 S-2024 QC Calorie Labeling IRR PNA Article on QC Guidelines PhilStar: How QC's rule will change menus Notes: IMPORTANT: Work on this has already been started and is partially complete Next developer needs to validate, confirm, and test the implementation Coordinate with kiosk frontend team to ensure proper display of calorie information This is a compliance requirement with legal deadlines - prioritize accordingly May need to work with clients to ensure their menu items have calorie data populated in POS Consider adding API versioning if this is a breaking change Next Steps: Validate the database column mapping is correct Update DTOs to include calorie field Test thoroughly with real POS data Update API documentation Coordinate with frontend team for kiosk UI updates Plan deployment timeline to meet Phase 1 deadline (Dec 20, 2025)","title":"Calorie Count (kcal) Inclusion in Items Endpoint Response"},{"location":"projects/kwikpos-api/roadmap.html#notes-for-future-developers","text":"","title":"Notes for Future Developers"},{"location":"projects/kwikpos-api/roadmap.html#general-context","text":"This project was personally started by myself, and its currently what I would call a \"good\" and flexible project that can adapt to requirement changes. Technically, this started to allow backwards compatibility with our modern self-ordering kiosk products to send orders to existing clients with their legacy POS devices. Do note that it might be updated in the future where you would need to integrate other POS provider's applications to allow our own products to still be sold.","title":"General Context"},{"location":"projects/kwikpos-api/roadmap.html#on-premise-deployment-considerations","text":"The setting up and deployment would technically be handled by the helpdesk support teams. Do coordinate with them for these kinds of deployments with clients.","title":"On-Premise Deployment Considerations"},{"location":"projects/kwikpos-api/roadmap.html#key-contacts","text":"Helpdesk Support: Tyrese","title":"Key Contacts"},{"location":"projects/kwikpos-api/roadmap.html#things-to-keep-in-mind","text":"Always confirm the modifications whether if it would be possible for us to do, or the change would be on the POS side. Always update the team lead or the project manager if the modifications requested after deployment needs to be billed or charged before implementing.","title":"Things to Keep in Mind"},{"location":"projects/kwikpos-api/roadmap.html#timeline-prioritization","text":"","title":"Timeline &amp; Prioritization"},{"location":"projects/kwikpos-api/roadmap.html#q4-2025-q1-2026-immediate-priority","text":"Calorie Count Implementation - MUST complete before Phase 1 deadline (Dec 20, 2025) Complete database column mapping validation Finalize SQL query updates Testing and validation Deployment to individual client store branches with KwikPOS API","title":"Q4 2025 / Q1 2026 (Immediate Priority)"},{"location":"projects/kwikpos-api/roadmap.html#2026-as-needed","text":"KwikPOS Terminal Support - Timeline TBD based on product launch schedule Requirements gathering and technical design Implementation of table management features Waiter authentication and order assignment Testing with actual terminal devices","title":"2026 (As Needed)"},{"location":"projects/kwikpos-api/roadmap.html#future-no-specific-timeline","text":"Multi-POS Provider Support - Will be triggered by sales team requirements Determine which POS systems to support based on client demand Design abstraction layer for multi-POS compatibility Implement adapters for priority POS systems Testing and validation with each POS provider","title":"Future (No Specific Timeline)"},{"location":"projects/kwikpos-api/roadmap.html#ongoing","text":"Bug fixes and technical improvements as identified Performance optimizations Security updates and patches","title":"Ongoing"},{"location":"projects/kwikpos-api/setup.html","text":"Prerequisites Refer to Prerequisites for detailed requirements. For KwikPOS API, you need: OpenJDK 17 ( Zulu ) Maven 3.8+ Apache Tomcat 10.0 (for local testing) Git Local Setup Steps 1. Clone the Repository git clone https://github.com/oct-ph/kwikpos-legacy-adapter.git cd kwikpos-legacy-adapter 2. Configure Application Edit application-dev.properties file and configure settings for schemas: spring.datasource.username=springboot spring.datasource.password=<PASSWORD_HERE> mybatis.configuration-properties.orderdb-schema=orderdb mybatis.configuration-properties.posdb-schema=posdb app.storage.local.base-path=D:/KwikPOS API/media/files Note: You can find and download these profile-specific .properties files here . Warning: Do not commit and push the application-dev.properties or the application-production.properties in source control for this project. 3. Build the Project mvn clean install 4. Run Locally # Using Spring Boot mvn spring-boot:run # Or deploy WAR to local Tomcat 10 cp target/kwikpos-legacy-adapter.war /path/to/tomcat10/webapps/ Note: When running the embedded tomcat server for local development, this project is special as it has this funcationality of hot-reload whenever code gets saved. 5. Verify Installation Access via: http://localhost:8083 http://localhost:8083/swagger-ui/index.html (Swagger UI) Test API endpoints using Postman Verify kiosk connectivity Additional Resources Spring Boot 3.5.4 Documentation Apache Tomcat 10.0 Documentation Kiosk API Specification","title":"Development Setup"},{"location":"projects/kwikpos-api/setup.html#prerequisites","text":"Refer to Prerequisites for detailed requirements. For KwikPOS API, you need: OpenJDK 17 ( Zulu ) Maven 3.8+ Apache Tomcat 10.0 (for local testing) Git","title":"Prerequisites"},{"location":"projects/kwikpos-api/setup.html#local-setup-steps","text":"","title":"Local Setup Steps"},{"location":"projects/kwikpos-api/setup.html#1-clone-the-repository","text":"git clone https://github.com/oct-ph/kwikpos-legacy-adapter.git cd kwikpos-legacy-adapter","title":"1. Clone the Repository"},{"location":"projects/kwikpos-api/setup.html#2-configure-application","text":"Edit application-dev.properties file and configure settings for schemas: spring.datasource.username=springboot spring.datasource.password=<PASSWORD_HERE> mybatis.configuration-properties.orderdb-schema=orderdb mybatis.configuration-properties.posdb-schema=posdb app.storage.local.base-path=D:/KwikPOS API/media/files Note: You can find and download these profile-specific .properties files here . Warning: Do not commit and push the application-dev.properties or the application-production.properties in source control for this project.","title":"2. Configure Application"},{"location":"projects/kwikpos-api/setup.html#3-build-the-project","text":"mvn clean install","title":"3. Build the Project"},{"location":"projects/kwikpos-api/setup.html#4-run-locally","text":"# Using Spring Boot mvn spring-boot:run # Or deploy WAR to local Tomcat 10 cp target/kwikpos-legacy-adapter.war /path/to/tomcat10/webapps/ Note: When running the embedded tomcat server for local development, this project is special as it has this funcationality of hot-reload whenever code gets saved.","title":"4. Run Locally"},{"location":"projects/kwikpos-api/setup.html#5-verify-installation","text":"Access via: http://localhost:8083 http://localhost:8083/swagger-ui/index.html (Swagger UI) Test API endpoints using Postman Verify kiosk connectivity","title":"5. Verify Installation"},{"location":"projects/kwikpos-api/setup.html#additional-resources","text":"Spring Boot 3.5.4 Documentation Apache Tomcat 10.0 Documentation Kiosk API Specification","title":"Additional Resources"},{"location":"projects/kwikpos-api/structure.html","text":"kwikpos-legacy-adapter/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main/ \u2502 \u2502 \u251c\u2500\u2500 java/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 com/oneclicktech/kwikpos_legacy_adapter \u2502 \u2502 \u2502 \u251c\u2500\u2500 component/ # Component classes \u2502 \u2502 \u2502 \u251c\u2500\u2500 config/ # Configuration classes \u2502 \u2502 \u2502 \u251c\u2500\u2500 controller/ # REST controllers \u2502 \u2502 \u2502 \u251c\u2500\u2500 enums/ # Enum objects \u2502 \u2502 \u2502 \u251c\u2500\u2500 mapper/ # Mapper interface methods (SQL Queries) \u2502 \u2502 \u2502 \u251c\u2500\u2500 model/ # Data entity models \u2502 \u2502 \u2502 \u251c\u2500\u2500 security/ # Security configurations \u2502 \u2502 \u2502 \u251c\u2500\u2500 service/ # Business logic \u2502 \u2502 \u2502 \u2514\u2500\u2500 utils/ # Global utility classes \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources/ \u2502 \u2502 \u251c\u2500\u2500 application.properties \u2502 \u2502 \u251c\u2500\u2500 application-dev.properties \u2502 \u2502 \u251c\u2500\u2500 application-production.properties \u2502 \u2502 \u2514\u2500\u2500 static/ # Static asset files (Img, CSS, JS, etc.) \u2502 \u2502 \u2502 \u2514\u2500\u2500 test/ # Unit tests \u251c\u2500\u2500 pom.xml # Maven configuration \u2514\u2500\u2500 README.md Package Overview component/ Component classes for cross-cutting concerns such as automatic BASE URL resolution for deployment environments, scheduled tasks (e.g., clearing pending sales orders after 1 hour), and other reusable utilities. config/ Configuration classes for Spring Boot application settings, including async configuration, AWS integration, caching, CORS policies, OpenAPI documentation, task scheduling, and storage backend configurations. controller/ REST controllers that handle HTTP requests from kiosks. Endpoints are designed to receive order data in modern formats. enums/ Enum objects that define fixed sets of constants used throughout the application for type-safe value representation. mapper/ MyBatis mapper interfaces defining SQL queries for database operations with both the order database and POS database. model/ Entity models representing both modern order structures and legacy POS data structures. security/ Security configuration classes that handle authentication, authorization, and other security-related functionality. service/ Business logic layer that handles order transformation and POS communication. This is where the adapter logic resides. utils/ Global utility classes that provide helper functions and common functionality across the application, not limited to specific resources.","title":"Project Structure"},{"location":"projects/kwikpos-api/structure.html#package-overview","text":"","title":"Package Overview"},{"location":"projects/kwikpos-api/structure.html#component","text":"Component classes for cross-cutting concerns such as automatic BASE URL resolution for deployment environments, scheduled tasks (e.g., clearing pending sales orders after 1 hour), and other reusable utilities.","title":"component/"},{"location":"projects/kwikpos-api/structure.html#config","text":"Configuration classes for Spring Boot application settings, including async configuration, AWS integration, caching, CORS policies, OpenAPI documentation, task scheduling, and storage backend configurations.","title":"config/"},{"location":"projects/kwikpos-api/structure.html#controller","text":"REST controllers that handle HTTP requests from kiosks. Endpoints are designed to receive order data in modern formats.","title":"controller/"},{"location":"projects/kwikpos-api/structure.html#enums","text":"Enum objects that define fixed sets of constants used throughout the application for type-safe value representation.","title":"enums/"},{"location":"projects/kwikpos-api/structure.html#mapper","text":"MyBatis mapper interfaces defining SQL queries for database operations with both the order database and POS database.","title":"mapper/"},{"location":"projects/kwikpos-api/structure.html#model","text":"Entity models representing both modern order structures and legacy POS data structures.","title":"model/"},{"location":"projects/kwikpos-api/structure.html#security","text":"Security configuration classes that handle authentication, authorization, and other security-related functionality.","title":"security/"},{"location":"projects/kwikpos-api/structure.html#service","text":"Business logic layer that handles order transformation and POS communication. This is where the adapter logic resides.","title":"service/"},{"location":"projects/kwikpos-api/structure.html#utils","text":"Global utility classes that provide helper functions and common functionality across the application, not limited to specific resources.","title":"utils/"},{"location":"projects/kwikpos-api/testing.html","text":"Local Testing Run All Tests mvn test Run Specific Test Class mvn test -Dtest=YourTestClass Run Integration Tests mvn verify Manual Testing Use Postman to simulate kiosk orders Test different order types and configurations Verify error handling Check transformation accuracy Integration Testing Test with actual kiosk if available Verify POS system receives correct data Test concurrent order handling Check system performance under load Note: We have several POS testing units at the office. Use these for integration tests. Testing Checklist When testing new features or changes: Unit tests pass locally Integration tests pass Postman collection tests successful Order transformation verified POS communication tested (if available) Error handling scenarios covered Concurrent request handling verified Performance under load tested","title":"Testing"},{"location":"projects/kwikpos-api/testing.html#local-testing","text":"","title":"Local Testing"},{"location":"projects/kwikpos-api/testing.html#run-all-tests","text":"mvn test","title":"Run All Tests"},{"location":"projects/kwikpos-api/testing.html#run-specific-test-class","text":"mvn test -Dtest=YourTestClass","title":"Run Specific Test Class"},{"location":"projects/kwikpos-api/testing.html#run-integration-tests","text":"mvn verify","title":"Run Integration Tests"},{"location":"projects/kwikpos-api/testing.html#manual-testing","text":"Use Postman to simulate kiosk orders Test different order types and configurations Verify error handling Check transformation accuracy","title":"Manual Testing"},{"location":"projects/kwikpos-api/testing.html#integration-testing","text":"Test with actual kiosk if available Verify POS system receives correct data Test concurrent order handling Check system performance under load Note: We have several POS testing units at the office. Use these for integration tests.","title":"Integration Testing"},{"location":"projects/kwikpos-api/testing.html#testing-checklist","text":"When testing new features or changes: Unit tests pass locally Integration tests pass Postman collection tests successful Order transformation verified POS communication tested (if available) Error handling scenarios covered Concurrent request handling verified Performance under load tested","title":"Testing Checklist"},{"location":"projects/kwikpos-api/troubleshooting.html","text":"Common Issues Build Failures Symptoms: Maven build fails or produces errors Solutions: Verify JDK 17 is active: java -version Clean Maven cache: mvn clean Update dependencies: mvn dependency:resolve Connection Issues Symptoms: Kiosks cannot reach the API server Solutions: Verify kiosk can reach the API server Check firewall settings Ensure correct port configuration Test network connectivity POS Integration Issues Symptoms: Orders not appearing in POS system Solutions: Verify POS system is running Check POS connection settings Review transformation logic Check POS system logs Tomcat Deployment Issues Symptoms: Application fails to deploy or start Solutions: Ensure using Tomcat 10.0 (not 9.0) Check Tomcat logs in logs/catalina.out Verify WAR file compatibility Ensure port is available Getting Additional Help If issues persist: Technical Questions: Reach out to the development team, or you may contact the original author of the codebase via email ( adrnmlgrto.dev@gmail.com ) Integration Issues: Consult with technical support or helpdesk Deployment Problems: Contact on-site technical support or helpdesk Architecture Questions: Review adapter patterns or consult senior developers Kiosk Issues: Check with KwikPOS Pro development team","title":"Troubleshooting"},{"location":"projects/kwikpos-api/troubleshooting.html#common-issues","text":"","title":"Common Issues"},{"location":"projects/kwikpos-api/troubleshooting.html#build-failures","text":"Symptoms: Maven build fails or produces errors Solutions: Verify JDK 17 is active: java -version Clean Maven cache: mvn clean Update dependencies: mvn dependency:resolve","title":"Build Failures"},{"location":"projects/kwikpos-api/troubleshooting.html#connection-issues","text":"Symptoms: Kiosks cannot reach the API server Solutions: Verify kiosk can reach the API server Check firewall settings Ensure correct port configuration Test network connectivity","title":"Connection Issues"},{"location":"projects/kwikpos-api/troubleshooting.html#pos-integration-issues","text":"Symptoms: Orders not appearing in POS system Solutions: Verify POS system is running Check POS connection settings Review transformation logic Check POS system logs","title":"POS Integration Issues"},{"location":"projects/kwikpos-api/troubleshooting.html#tomcat-deployment-issues","text":"Symptoms: Application fails to deploy or start Solutions: Ensure using Tomcat 10.0 (not 9.0) Check Tomcat logs in logs/catalina.out Verify WAR file compatibility Ensure port is available","title":"Tomcat Deployment Issues"},{"location":"projects/kwikpos-api/troubleshooting.html#getting-additional-help","text":"If issues persist: Technical Questions: Reach out to the development team, or you may contact the original author of the codebase via email ( adrnmlgrto.dev@gmail.com ) Integration Issues: Consult with technical support or helpdesk Deployment Problems: Contact on-site technical support or helpdesk Architecture Questions: Review adapter patterns or consult senior developers Kiosk Issues: Check with KwikPOS Pro development team","title":"Getting Additional Help"},{"location":"projects/kwikpos-fullybooked/index.html","text":"Purpose: Custom integration between KwikPOS POS system and FullyBooked's IMS system This project handles the integration between KwikPOS POS terminals and FullyBooked's (a bookstore chain) IMS systems, primarily focusing on data exchange through text file imports/exports and custom SQL queries for data retrieval and manipulation. Project Context This is a client-specific integration project developed to meet FullyBooked's unique business requirements. The integration is primarily database-centric, involving custom SQL queries, database views, and text file-based data exchange. Their POS application is a heavily modified version of WinPOS, which is technically the legacy version of the retail POS we provide. Do keep this in mind as there might be columns and tables not a part of the standard retail POS. Note: This project was not primarily developed by the current documentation author. Most involvement was limited to SQL query modifications and database-level work. Tech Stack Database: MS SQL Server Application Server: Apache Tomcat 9.0 Backend Framework: Spring Boot 2.7.2 Java Version: Java 11 (likely, but unconfirmed) Export/Import Tools: KwikPOS WebExt Web Application File Format: Text files (tab-delimited) Deployment: On-premise (loaded on individual FullyBooked POS machines) Note: While this integration runs on a Spring Boot application deployed via Tomcat, most development work involves database/SQL-level modifications rather than application code changes. Database Configuration Database Schemas The FullyBooked integration utilizes multiple MS SQL Server databases: serverposdb Purpose: Primary POS application database Usage: Main database where most SQL view editing and modifications occur Role: Contains core POS data for transactions, items, and operations Development Note: This is the primary database you'll work with when creating or modifying views for data exports KwikPOS_AddIn Purpose: Spring Boot integration configuration database Usage: Stores integration-specific settings and configurations Key Contents: User configurations Cron job settings (e.g., boolean flags for enabling/disabling scheduled text file exports to IMS) FTP connection details (IP addresses, credentials) Database-centric approach configuration tables dbo.FB_IMSFILE_LKP - Lookup table for IMS file exports Contains rows identifying resources to export Maps view tables to query for each export type Defines export configurations and mappings Database-Centric Approach: This integration follows a database-centric design pattern where configuration and logic are stored in database tables rather than hardcoded in the application, allowing for flexible modifications without code changes. Key Features Data Export System The integration exports data from the POS database to text files for FullyBooked's systems to consume. Primary Exports Include: - Transaction data - Detailed transaction data - Other POS data as required by FullyBooked Data Import System The integration imports data from FullyBooked's systems into the POS database via text files. Primary Imports Include: - Product/item data - Promos and discounts - Customer information - Pricing information - Other master data as needed Custom SQL Queries and Views A significant portion of the work involves maintaining and modifying SQL queries and database views for data extraction, transformation, and reporting. Quick Links Responsibilities - Core integration responsibilities Deployment - Infrastructure and technical details Development Tasks - Common workflows and development notes Troubleshooting - Known limitations and getting help Getting Help If you need assistance with this integration: SQL/Database Questions: Review existing views and queries in the database Data Format Issues: Check with FullyBooked's technical team for specifications Export/Import Problems: Review logs and validate file formats New Requirements: Coordinate with the development team or directly with the contact person in FullyBooked GCs","title":"Overview"},{"location":"projects/kwikpos-fullybooked/index.html#project-context","text":"This is a client-specific integration project developed to meet FullyBooked's unique business requirements. The integration is primarily database-centric, involving custom SQL queries, database views, and text file-based data exchange. Their POS application is a heavily modified version of WinPOS, which is technically the legacy version of the retail POS we provide. Do keep this in mind as there might be columns and tables not a part of the standard retail POS. Note: This project was not primarily developed by the current documentation author. Most involvement was limited to SQL query modifications and database-level work.","title":"Project Context"},{"location":"projects/kwikpos-fullybooked/index.html#tech-stack","text":"Database: MS SQL Server Application Server: Apache Tomcat 9.0 Backend Framework: Spring Boot 2.7.2 Java Version: Java 11 (likely, but unconfirmed) Export/Import Tools: KwikPOS WebExt Web Application File Format: Text files (tab-delimited) Deployment: On-premise (loaded on individual FullyBooked POS machines) Note: While this integration runs on a Spring Boot application deployed via Tomcat, most development work involves database/SQL-level modifications rather than application code changes.","title":"Tech Stack"},{"location":"projects/kwikpos-fullybooked/index.html#database-configuration","text":"","title":"Database Configuration"},{"location":"projects/kwikpos-fullybooked/index.html#database-schemas","text":"The FullyBooked integration utilizes multiple MS SQL Server databases:","title":"Database Schemas"},{"location":"projects/kwikpos-fullybooked/index.html#serverposdb","text":"Purpose: Primary POS application database Usage: Main database where most SQL view editing and modifications occur Role: Contains core POS data for transactions, items, and operations Development Note: This is the primary database you'll work with when creating or modifying views for data exports","title":"serverposdb"},{"location":"projects/kwikpos-fullybooked/index.html#kwikpos_addin","text":"Purpose: Spring Boot integration configuration database Usage: Stores integration-specific settings and configurations Key Contents: User configurations Cron job settings (e.g., boolean flags for enabling/disabling scheduled text file exports to IMS) FTP connection details (IP addresses, credentials) Database-centric approach configuration tables dbo.FB_IMSFILE_LKP - Lookup table for IMS file exports Contains rows identifying resources to export Maps view tables to query for each export type Defines export configurations and mappings Database-Centric Approach: This integration follows a database-centric design pattern where configuration and logic are stored in database tables rather than hardcoded in the application, allowing for flexible modifications without code changes.","title":"KwikPOS_AddIn"},{"location":"projects/kwikpos-fullybooked/index.html#key-features","text":"","title":"Key Features"},{"location":"projects/kwikpos-fullybooked/index.html#data-export-system","text":"The integration exports data from the POS database to text files for FullyBooked's systems to consume. Primary Exports Include: - Transaction data - Detailed transaction data - Other POS data as required by FullyBooked","title":"Data Export System"},{"location":"projects/kwikpos-fullybooked/index.html#data-import-system","text":"The integration imports data from FullyBooked's systems into the POS database via text files. Primary Imports Include: - Product/item data - Promos and discounts - Customer information - Pricing information - Other master data as needed","title":"Data Import System"},{"location":"projects/kwikpos-fullybooked/index.html#custom-sql-queries-and-views","text":"A significant portion of the work involves maintaining and modifying SQL queries and database views for data extraction, transformation, and reporting.","title":"Custom SQL Queries and Views"},{"location":"projects/kwikpos-fullybooked/index.html#quick-links","text":"Responsibilities - Core integration responsibilities Deployment - Infrastructure and technical details Development Tasks - Common workflows and development notes Troubleshooting - Known limitations and getting help","title":"Quick Links"},{"location":"projects/kwikpos-fullybooked/index.html#getting-help","text":"If you need assistance with this integration: SQL/Database Questions: Review existing views and queries in the database Data Format Issues: Check with FullyBooked's technical team for specifications Export/Import Problems: Review logs and validate file formats New Requirements: Coordinate with the development team or directly with the contact person in FullyBooked GCs","title":"Getting Help"},{"location":"projects/kwikpos-fullybooked/deployment.html","text":"This document covers the technical infrastructure and deployment details for the FullyBooked integration. Deployment Model On-Premise Deployment The integration is deployed on individual FullyBooked POS machines: Environment: On-premise at FullyBooked store locations Server: Apache Tomcat 9.0 Application: KwikPOS WebExt Web Application Database: MS SQL Server (co-located with POS application) Infrastructure The integration runs alongside the FullyBooked POS application: Deployed on the same machines as the FullyBooked POS system Direct database access to the POS database Text file-based data exchange with FullyBooked's IMS system File transfer via FTP, shared folders, or other mechanisms Prerequisites To work on this integration, you'll need: Database access credentials for the FullyBooked POS database Understanding of FullyBooked's data format specifications SQL query writing and optimization skills Database client tool (SQL Server Management Studio 19) Architecture Context Modified WinPOS Base The FullyBooked POS application is a heavily modified version of WinPOS, which is the legacy version of our retail POS product. Important: There may be columns and tables that are not part of the standard retail POS. Always verify the database schema when working with this integration. Integration Flow FullyBooked POS Database \u2193 SQL Views/Queries \u2193 WebExt Application \u2193 Text Files \u2193 FullyBooked IMS System Bidirectional Flow: - Export: POS \u2192 Text Files \u2192 IMS - Import: IMS \u2192 Text Files \u2192 POS","title":"Deployment"},{"location":"projects/kwikpos-fullybooked/deployment.html#deployment-model","text":"","title":"Deployment Model"},{"location":"projects/kwikpos-fullybooked/deployment.html#on-premise-deployment","text":"The integration is deployed on individual FullyBooked POS machines: Environment: On-premise at FullyBooked store locations Server: Apache Tomcat 9.0 Application: KwikPOS WebExt Web Application Database: MS SQL Server (co-located with POS application)","title":"On-Premise Deployment"},{"location":"projects/kwikpos-fullybooked/deployment.html#infrastructure","text":"The integration runs alongside the FullyBooked POS application: Deployed on the same machines as the FullyBooked POS system Direct database access to the POS database Text file-based data exchange with FullyBooked's IMS system File transfer via FTP, shared folders, or other mechanisms","title":"Infrastructure"},{"location":"projects/kwikpos-fullybooked/deployment.html#prerequisites","text":"To work on this integration, you'll need: Database access credentials for the FullyBooked POS database Understanding of FullyBooked's data format specifications SQL query writing and optimization skills Database client tool (SQL Server Management Studio 19)","title":"Prerequisites"},{"location":"projects/kwikpos-fullybooked/deployment.html#architecture-context","text":"","title":"Architecture Context"},{"location":"projects/kwikpos-fullybooked/deployment.html#modified-winpos-base","text":"The FullyBooked POS application is a heavily modified version of WinPOS, which is the legacy version of our retail POS product. Important: There may be columns and tables that are not part of the standard retail POS. Always verify the database schema when working with this integration.","title":"Modified WinPOS Base"},{"location":"projects/kwikpos-fullybooked/deployment.html#integration-flow","text":"FullyBooked POS Database \u2193 SQL Views/Queries \u2193 WebExt Application \u2193 Text Files \u2193 FullyBooked IMS System Bidirectional Flow: - Export: POS \u2192 Text Files \u2192 IMS - Import: IMS \u2192 Text Files \u2192 POS","title":"Integration Flow"},{"location":"projects/kwikpos-fullybooked/development.html","text":"This document provides guidance on common development tasks and workflows for the FullyBooked integration. Development Notes Limited Code Involvement Important Context: The core application code was developed by others Primary involvement has been at the database/SQL level Focus has been on query modifications and view maintenance Limited knowledge of the full application architecture SQL Work Most development work involves: Writing and modifying SQL queries Creating and updating database views Optimizing query performance Troubleshooting data export/import issues Common Tasks Typical tasks in this project include: Modifying Views - Updating existing views to include new fields or change data retrieval logic Query Optimization - Improving performance of slow-running queries Data Extraction - Writing new queries to retrieve specific transaction or item data Import Logic - Modifying import procedures to handle new data formats Data Validation - Ensuring imported/exported data meets requirements Common Workflows Modifying an Export View Identify the view that needs modification Review current view definition and data output Extract the SELECT statement from the view and make necessary modifications Update the corresponding CREATE OR ALTER VIEW statement in the SQL script file Test the modified view with sample data Verify export file format matches FullyBooked's requirements Deploy the updated view to production SQL Script File for View Updates FullyBooked View Updates Script \u2192 This SQL script file contains the complete deployment script for view updates, including the USE [sevrerposdb]; GO statement and full CREATE OR ALTER VIEW definitions. The file currently includes three export views: dbo.View_tblSaleTenderRequirement dbo.View_tblSaleTransaction dbo.View_tblSaleTransactionDetailed Development Workflow: Extract the SELECT portion from the target view Make your modifications to the SELECT statement as needed Update the full CREATE OR ALTER VIEW statement in this script file Provide the updated script file to helpdesk support for deployment Adding Updates for Other Views: This script only includes the three views listed above. If another export view table needs to be updated, add a new CREATE OR ALTER VIEW statement to this file below the existing views. This ensures helpdesk support can deploy all view updates using a single consolidated script file. Adding New Export Data Understand the new data requirements from FullyBooked Identify the KwikPOS_AddIn schema and update the table with dbo.FB_IMSFILE_LKP Create the view table in the serverposdb schema. Follow existing naming conventions based on existing view tables Update column with updated row to query the new SQL view in the dbo.FB_IMSFILE_LKP table Test export with real data Troubleshooting Import Issues Review import error logs Validate text file format against specifications Check for data type mismatches or constraint violations Test import procedure with problematic data Fix SQL import logic or data validation Re-run import and verify success Notes for Future Developers Important Considerations This is a client-specific integration - changes must be coordinated with FullyBooked Always test SQL changes with sample data before deployment Export file format changes require FullyBooked's approval Document any new views or queries you create Consider performance impact of query changes on production database When Making Changes Understand the requirement - Get clear specifications from FullyBooked Test thoroughly - Use sample data that covers edge cases Coordinate deployment - Schedule changes during low-traffic periods Monitor after deployment - Verify exports/imports work correctly Development Environment Database Tools Recommended tools for working with the FullyBooked integration: SQL Server Management Studio (SSMS) - Full-featured IDE for SQL Server Database client with SQL Server support SQL Best Practices When writing queries for this integration: Follow existing naming conventions for views and procedures Comment complex queries to explain business logic Test with realistic data volumes Consider indexing for performance-critical queries Validate data types match FullyBooked's specifications","title":"Development Tasks"},{"location":"projects/kwikpos-fullybooked/development.html#development-notes","text":"","title":"Development Notes"},{"location":"projects/kwikpos-fullybooked/development.html#limited-code-involvement","text":"Important Context: The core application code was developed by others Primary involvement has been at the database/SQL level Focus has been on query modifications and view maintenance Limited knowledge of the full application architecture","title":"Limited Code Involvement"},{"location":"projects/kwikpos-fullybooked/development.html#sql-work","text":"Most development work involves: Writing and modifying SQL queries Creating and updating database views Optimizing query performance Troubleshooting data export/import issues","title":"SQL Work"},{"location":"projects/kwikpos-fullybooked/development.html#common-tasks","text":"Typical tasks in this project include: Modifying Views - Updating existing views to include new fields or change data retrieval logic Query Optimization - Improving performance of slow-running queries Data Extraction - Writing new queries to retrieve specific transaction or item data Import Logic - Modifying import procedures to handle new data formats Data Validation - Ensuring imported/exported data meets requirements","title":"Common Tasks"},{"location":"projects/kwikpos-fullybooked/development.html#common-workflows","text":"","title":"Common Workflows"},{"location":"projects/kwikpos-fullybooked/development.html#modifying-an-export-view","text":"Identify the view that needs modification Review current view definition and data output Extract the SELECT statement from the view and make necessary modifications Update the corresponding CREATE OR ALTER VIEW statement in the SQL script file Test the modified view with sample data Verify export file format matches FullyBooked's requirements Deploy the updated view to production","title":"Modifying an Export View"},{"location":"projects/kwikpos-fullybooked/development.html#sql-script-file-for-view-updates","text":"FullyBooked View Updates Script \u2192 This SQL script file contains the complete deployment script for view updates, including the USE [sevrerposdb]; GO statement and full CREATE OR ALTER VIEW definitions. The file currently includes three export views: dbo.View_tblSaleTenderRequirement dbo.View_tblSaleTransaction dbo.View_tblSaleTransactionDetailed Development Workflow: Extract the SELECT portion from the target view Make your modifications to the SELECT statement as needed Update the full CREATE OR ALTER VIEW statement in this script file Provide the updated script file to helpdesk support for deployment Adding Updates for Other Views: This script only includes the three views listed above. If another export view table needs to be updated, add a new CREATE OR ALTER VIEW statement to this file below the existing views. This ensures helpdesk support can deploy all view updates using a single consolidated script file.","title":"SQL Script File for View Updates"},{"location":"projects/kwikpos-fullybooked/development.html#adding-new-export-data","text":"Understand the new data requirements from FullyBooked Identify the KwikPOS_AddIn schema and update the table with dbo.FB_IMSFILE_LKP Create the view table in the serverposdb schema. Follow existing naming conventions based on existing view tables Update column with updated row to query the new SQL view in the dbo.FB_IMSFILE_LKP table Test export with real data","title":"Adding New Export Data"},{"location":"projects/kwikpos-fullybooked/development.html#troubleshooting-import-issues","text":"Review import error logs Validate text file format against specifications Check for data type mismatches or constraint violations Test import procedure with problematic data Fix SQL import logic or data validation Re-run import and verify success","title":"Troubleshooting Import Issues"},{"location":"projects/kwikpos-fullybooked/development.html#notes-for-future-developers","text":"","title":"Notes for Future Developers"},{"location":"projects/kwikpos-fullybooked/development.html#important-considerations","text":"This is a client-specific integration - changes must be coordinated with FullyBooked Always test SQL changes with sample data before deployment Export file format changes require FullyBooked's approval Document any new views or queries you create Consider performance impact of query changes on production database","title":"Important Considerations"},{"location":"projects/kwikpos-fullybooked/development.html#when-making-changes","text":"Understand the requirement - Get clear specifications from FullyBooked Test thoroughly - Use sample data that covers edge cases Coordinate deployment - Schedule changes during low-traffic periods Monitor after deployment - Verify exports/imports work correctly","title":"When Making Changes"},{"location":"projects/kwikpos-fullybooked/development.html#development-environment","text":"","title":"Development Environment"},{"location":"projects/kwikpos-fullybooked/development.html#database-tools","text":"Recommended tools for working with the FullyBooked integration: SQL Server Management Studio (SSMS) - Full-featured IDE for SQL Server Database client with SQL Server support","title":"Database Tools"},{"location":"projects/kwikpos-fullybooked/development.html#sql-best-practices","text":"When writing queries for this integration: Follow existing naming conventions for views and procedures Comment complex queries to explain business logic Test with realistic data volumes Consider indexing for performance-critical queries Validate data types match FullyBooked's specifications","title":"SQL Best Practices"},{"location":"projects/kwikpos-fullybooked/responsibilities.html","text":"This document outlines the core responsibilities of the KwikPOS x FullyBooked integration system. Data Export Overview Generate text file exports containing POS transaction data for FullyBooked's systems to consume. Key Responsibilities Generate text file exports containing POS transaction data Format data according to FullyBooked's specifications Ensure data accuracy and completeness Handle export scheduling (manual or automated) Export Mechanism Data is exported as text files Custom SQL views are used to retrieve and format the data Exports are generated based on FullyBooked's specific data format requirements Primary Exports Include Transaction data Detailed transaction data Other POS data as required by FullyBooked Data Import Overview Process text file imports from FullyBooked's systems into the POS database. Key Responsibilities Process text file imports from FullyBooked's systems Validate and transform incoming data Insert/update POS database with imported data Handle data conflicts and errors Import Mechanism Text file-based imports Custom SQL procedures or scripts to process and insert data Data validation and transformation during import Primary Imports Include Product/item data Promos and discounts Customer information Pricing information Other master data as needed Database Maintenance Overview Maintain and optimize SQL queries and database views that power the integration. Key Responsibilities Maintain and modify SQL views for data retrieval Optimize queries for performance Create new views or queries as requirements evolve Ensure data integrity during import/export operations Database Views Custom views created to retrieve transaction data Views optimized for FullyBooked's specific reporting needs Views that transform POS data into FullyBooked's required format SQL Query Modifications Modifying existing views to accommodate new data requirements Creating new queries for data extraction Optimizing query performance for large datasets Technical Approach Database-Centric Integration The integration primarily operates at the database level: Custom SQL views for data retrieval Stored procedures or scripts for data import/export Database triggers (if applicable) for automated processes Direct database access for FullyBooked's systems or middleware Text File Format Data exchange uses text files as the medium: Export Format: Text files (CSV, tab-delimited, or fixed-width) Import Format: Text files provided by FullyBooked File transfer mechanism (FTP, shared folder, or other)","title":"Responsibilities"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#data-export","text":"","title":"Data Export"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#overview","text":"Generate text file exports containing POS transaction data for FullyBooked's systems to consume.","title":"Overview"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#key-responsibilities","text":"Generate text file exports containing POS transaction data Format data according to FullyBooked's specifications Ensure data accuracy and completeness Handle export scheduling (manual or automated)","title":"Key Responsibilities"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#export-mechanism","text":"Data is exported as text files Custom SQL views are used to retrieve and format the data Exports are generated based on FullyBooked's specific data format requirements","title":"Export Mechanism"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#primary-exports-include","text":"Transaction data Detailed transaction data Other POS data as required by FullyBooked","title":"Primary Exports Include"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#data-import","text":"","title":"Data Import"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#overview_1","text":"Process text file imports from FullyBooked's systems into the POS database.","title":"Overview"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#key-responsibilities_1","text":"Process text file imports from FullyBooked's systems Validate and transform incoming data Insert/update POS database with imported data Handle data conflicts and errors","title":"Key Responsibilities"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#import-mechanism","text":"Text file-based imports Custom SQL procedures or scripts to process and insert data Data validation and transformation during import","title":"Import Mechanism"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#primary-imports-include","text":"Product/item data Promos and discounts Customer information Pricing information Other master data as needed","title":"Primary Imports Include"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#database-maintenance","text":"","title":"Database Maintenance"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#overview_2","text":"Maintain and optimize SQL queries and database views that power the integration.","title":"Overview"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#key-responsibilities_2","text":"Maintain and modify SQL views for data retrieval Optimize queries for performance Create new views or queries as requirements evolve Ensure data integrity during import/export operations","title":"Key Responsibilities"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#database-views","text":"Custom views created to retrieve transaction data Views optimized for FullyBooked's specific reporting needs Views that transform POS data into FullyBooked's required format","title":"Database Views"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#sql-query-modifications","text":"Modifying existing views to accommodate new data requirements Creating new queries for data extraction Optimizing query performance for large datasets","title":"SQL Query Modifications"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#technical-approach","text":"","title":"Technical Approach"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#database-centric-integration","text":"The integration primarily operates at the database level: Custom SQL views for data retrieval Stored procedures or scripts for data import/export Database triggers (if applicable) for automated processes Direct database access for FullyBooked's systems or middleware","title":"Database-Centric Integration"},{"location":"projects/kwikpos-fullybooked/responsibilities.html#text-file-format","text":"Data exchange uses text files as the medium: Export Format: Text files (CSV, tab-delimited, or fixed-width) Import Format: Text files provided by FullyBooked File transfer mechanism (FTP, shared folder, or other)","title":"Text File Format"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html","text":"This document provides a comprehensive reference of all tender types used in the FullyBooked integration and their associated requirement field IDs. Each tender type has specific fields that must be captured during the transaction process. Overview Tender requirements define the additional information that needs to be collected for each payment method. The requirement IDs map to specific fields in the tblSaleTenderRequirement table and are used in the export views for FullyBooked. Common Requirement ID: Requirement ID 0 (Tendered Amount/Amount) is used across all tender types to capture the payment amount. Cash Tender Tender ID: 1 Requirement ID Field Name 59 Remarks 167 Customer 168 TIN No. 169 Address 0 Tendered Amount Credit Card Tender ID: 2 Requirement ID Field Name 1 Credit Card No. 2 Name (Credit Card Holder) 3 Expiration Date 4 Approval Code 14 Credit Card Type 77 Remarks 95 Order No. 96 Payment Reference No. 97 Courier 98 Tracking No. 99 Shipping Fee 170 Customer 171 TIN No. 172 Address 0 Tendered Amount Check Tender ID: 3 Requirement ID Field Name 5 Bank 6 Cheque No. 7 Date 78 Remarks 173 Customer 174 TIN No. 175 Address 0 Amount Exchange Tender ID: 5 Requirement ID Field Name 9 Exchange No. 0 Amount Gift Cheque Tender ID: 6 Requirement ID Field Name 10 Gift Cheque No. 79 Remarks 0 Amount GCash Tender ID: 8 Requirement ID Field Name 12 Order No. 13 Payment Reference No. 64 Courier 65 Tracking No. 66 Shipping Fee 80 Remarks 176 Customer 177 TIN No. 178 Address 0 Amount Others Tender ID: 10 Requirement ID Field Name 19 Tender Name 20 Remarks 179 Customer 180 TIN No. 181 Address 0 Amount FBEGC (FullyBooked E-Gift Certificate) Tender ID: 12 Requirement ID Field Name 25 FBEGC No. 26 Trace No. 83 Remarks 182 Customer 183 TIN No. 184 Address 0 Amount DragonPay Tender ID: 13 Requirement ID Field Name 27 Order No. 55 Payment Reference No. 56 Courier 57 Tracking No. 58 Shipping Fee 0 Amount CWT (Creditable Withholding Tax) Tender ID: 15 Requirement ID Field Name 29 TIN No. 30 Payees Name 31 Period 32 ATC Code 0 Amount Gifted Tender ID: 16 Requirement ID Field Name 33 Voucher No. 84 Remarks 185 Customer 186 TIN No. 187 Address 0 Amount Lazada Tender ID: 21 Requirement ID Field Name 38 Confirmation No. 67 Payment Mode 0 Amount Giftway Tender ID: 22 Requirement ID Field Name 39 Voucher No. 85 Remarks 188 Customer 189 TIN No. 190 Address 0 Amount Shopee Tender ID: 23 Requirement ID Field Name 40 Order No. 68 Payment Mode 69 Courier 0 Amount COD (Cash on Delivery) Tender ID: 31 Requirement ID Field Name 48 Order No. 52 Courier 53 Tracking No. 54 Shipping Fee 126 Remarks 0 Amount WeChat Tender ID: 32 Requirement ID Field Name 49 Reference No. 86 Remarks 191 Customer 192 TIN No. 193 Address 0 Amount Alipay Tender ID: 33 Requirement ID Field Name 50 Reference No. 87 Remarks 194 Customer 195 TIN No. 196 Address 0 Amount GrabMart Tender ID: 34 Requirement ID Field Name 51 Reference No. 88 Remarks 197 Customer 198 TIN No. 199 Address 0 Amount Bank Transfer Tender ID: 36 Not Implemented: This tender type is not yet implemented in the export query. Requirement ID Field Name 70 Order No. 71 Bank Name 72 Payment Reference No. 73 Courier 74 Tracking No. 75 Shipping Fee 0 Amount GLife Tender ID: 39 Requirement ID Field Name 100 Order No. 101 Payment Reference No. 102 Courier 103 Tracking No. 104 Shipping Fee 105 Remarks 0 Amount ShopeePay Tender ID: 40 Requirement ID Field Name 106 Payment Reference No. 107 Remarks 203 Customer 204 TIN No. 205 Address 0 Amount Store Credit Tender ID: 43 Requirement ID Field Name 127 Order No. 128 Payment Reference No. 129 Courier 130 Tracking No. 131 Shipping Fee 132 Remarks 0 Amount Virtual GC (Gift Certificate) Tender ID: 44 Requirement ID Field Name 133 Order No. 134 Payment Reference No. 135 Courier 136 Tracking No. 137 Shipping Fee 138 Remarks 0 Amount Cashback Tender ID: 45 Requirement ID Field Name 139 Order No. 140 Payment Reference No. 141 Courier 142 Tracking No. 143 Shipping Fee 144 Remarks 0 Amount Digital Wallet Tender ID: 46 Requirement ID Field Name 145 Order No. 146 Payment Reference No. 147 Courier 148 Tracking No. 149 Shipping Fee 150 Remarks 0 Amount BDO - Debit Tender ID: 47 Requirement ID Field Name 151 Remarks 152 Customer 153 TIN No. 154 Address 0 Amount Metrobank - Debit Tender ID: 48 Requirement ID Field Name 163 Remarks 164 Customer 165 TIN No. 166 Address 0 Amount BDO E-Wallet Tender ID: 49 Requirement ID Field Name 159 Remarks 160 Customer 161 TIN No. 162 Address 0 Amount Metrobank E-Wallet Tender ID: 50 Requirement ID Field Name 163 Remarks 164 Customer 165 TIN No. 166 Address 0 Amount TikTok Tender ID: 62 Pending Implementation: This tender type has not been implemented yet. Requirement IDs need to be provided by FullyBooked. Requirement ID Field Name TBD Order No. TBD Payment Mode TBD Courier 0 Amount Usage Notes Working with Tender Requirements When modifying tender requirement mappings: Identify the Tender ID - Determine which payment method you're working with Locate Requirement IDs - Reference this document for the specific field IDs needed Update View Logic - Modify the SQL view to include/exclude requirement fields Test Thoroughly - Verify that all required fields are captured correctly Common Field Patterns Several requirement fields appear across multiple tender types: Customer Information : Customer, TIN No., Address Order Details : Order No., Payment Reference No. Shipping Information : Courier, Tracking No., Shipping Fee General : Remarks, Amount Adding New Tender Types When FullyBooked introduces a new payment method: Obtain the Tender ID and all requirement field IDs from FullyBooked Add the new tender type to this documentation Update the dbo.View_tblSaleTenderRequirement view to include the new mappings Test the export with sample transactions using the new tender type","title":"Tender Requirements Map"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#overview","text":"Tender requirements define the additional information that needs to be collected for each payment method. The requirement IDs map to specific fields in the tblSaleTenderRequirement table and are used in the export views for FullyBooked. Common Requirement ID: Requirement ID 0 (Tendered Amount/Amount) is used across all tender types to capture the payment amount.","title":"Overview"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#cash-tender","text":"Tender ID: 1 Requirement ID Field Name 59 Remarks 167 Customer 168 TIN No. 169 Address 0 Tendered Amount","title":"Cash Tender"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#credit-card","text":"Tender ID: 2 Requirement ID Field Name 1 Credit Card No. 2 Name (Credit Card Holder) 3 Expiration Date 4 Approval Code 14 Credit Card Type 77 Remarks 95 Order No. 96 Payment Reference No. 97 Courier 98 Tracking No. 99 Shipping Fee 170 Customer 171 TIN No. 172 Address 0 Tendered Amount","title":"Credit Card"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#check","text":"Tender ID: 3 Requirement ID Field Name 5 Bank 6 Cheque No. 7 Date 78 Remarks 173 Customer 174 TIN No. 175 Address 0 Amount","title":"Check"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#exchange","text":"Tender ID: 5 Requirement ID Field Name 9 Exchange No. 0 Amount","title":"Exchange"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#gift-cheque","text":"Tender ID: 6 Requirement ID Field Name 10 Gift Cheque No. 79 Remarks 0 Amount","title":"Gift Cheque"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#gcash","text":"Tender ID: 8 Requirement ID Field Name 12 Order No. 13 Payment Reference No. 64 Courier 65 Tracking No. 66 Shipping Fee 80 Remarks 176 Customer 177 TIN No. 178 Address 0 Amount","title":"GCash"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#others","text":"Tender ID: 10 Requirement ID Field Name 19 Tender Name 20 Remarks 179 Customer 180 TIN No. 181 Address 0 Amount","title":"Others"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#fbegc-fullybooked-e-gift-certificate","text":"Tender ID: 12 Requirement ID Field Name 25 FBEGC No. 26 Trace No. 83 Remarks 182 Customer 183 TIN No. 184 Address 0 Amount","title":"FBEGC (FullyBooked E-Gift Certificate)"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#dragonpay","text":"Tender ID: 13 Requirement ID Field Name 27 Order No. 55 Payment Reference No. 56 Courier 57 Tracking No. 58 Shipping Fee 0 Amount","title":"DragonPay"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#cwt-creditable-withholding-tax","text":"Tender ID: 15 Requirement ID Field Name 29 TIN No. 30 Payees Name 31 Period 32 ATC Code 0 Amount","title":"CWT (Creditable Withholding Tax)"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#gifted","text":"Tender ID: 16 Requirement ID Field Name 33 Voucher No. 84 Remarks 185 Customer 186 TIN No. 187 Address 0 Amount","title":"Gifted"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#lazada","text":"Tender ID: 21 Requirement ID Field Name 38 Confirmation No. 67 Payment Mode 0 Amount","title":"Lazada"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#giftway","text":"Tender ID: 22 Requirement ID Field Name 39 Voucher No. 85 Remarks 188 Customer 189 TIN No. 190 Address 0 Amount","title":"Giftway"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#shopee","text":"Tender ID: 23 Requirement ID Field Name 40 Order No. 68 Payment Mode 69 Courier 0 Amount","title":"Shopee"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#cod-cash-on-delivery","text":"Tender ID: 31 Requirement ID Field Name 48 Order No. 52 Courier 53 Tracking No. 54 Shipping Fee 126 Remarks 0 Amount","title":"COD (Cash on Delivery)"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#wechat","text":"Tender ID: 32 Requirement ID Field Name 49 Reference No. 86 Remarks 191 Customer 192 TIN No. 193 Address 0 Amount","title":"WeChat"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#alipay","text":"Tender ID: 33 Requirement ID Field Name 50 Reference No. 87 Remarks 194 Customer 195 TIN No. 196 Address 0 Amount","title":"Alipay"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#grabmart","text":"Tender ID: 34 Requirement ID Field Name 51 Reference No. 88 Remarks 197 Customer 198 TIN No. 199 Address 0 Amount","title":"GrabMart"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#bank-transfer","text":"Tender ID: 36 Not Implemented: This tender type is not yet implemented in the export query. Requirement ID Field Name 70 Order No. 71 Bank Name 72 Payment Reference No. 73 Courier 74 Tracking No. 75 Shipping Fee 0 Amount","title":"Bank Transfer"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#glife","text":"Tender ID: 39 Requirement ID Field Name 100 Order No. 101 Payment Reference No. 102 Courier 103 Tracking No. 104 Shipping Fee 105 Remarks 0 Amount","title":"GLife"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#shopeepay","text":"Tender ID: 40 Requirement ID Field Name 106 Payment Reference No. 107 Remarks 203 Customer 204 TIN No. 205 Address 0 Amount","title":"ShopeePay"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#store-credit","text":"Tender ID: 43 Requirement ID Field Name 127 Order No. 128 Payment Reference No. 129 Courier 130 Tracking No. 131 Shipping Fee 132 Remarks 0 Amount","title":"Store Credit"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#virtual-gc-gift-certificate","text":"Tender ID: 44 Requirement ID Field Name 133 Order No. 134 Payment Reference No. 135 Courier 136 Tracking No. 137 Shipping Fee 138 Remarks 0 Amount","title":"Virtual GC (Gift Certificate)"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#cashback","text":"Tender ID: 45 Requirement ID Field Name 139 Order No. 140 Payment Reference No. 141 Courier 142 Tracking No. 143 Shipping Fee 144 Remarks 0 Amount","title":"Cashback"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#digital-wallet","text":"Tender ID: 46 Requirement ID Field Name 145 Order No. 146 Payment Reference No. 147 Courier 148 Tracking No. 149 Shipping Fee 150 Remarks 0 Amount","title":"Digital Wallet"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#bdo-debit","text":"Tender ID: 47 Requirement ID Field Name 151 Remarks 152 Customer 153 TIN No. 154 Address 0 Amount","title":"BDO - Debit"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#metrobank-debit","text":"Tender ID: 48 Requirement ID Field Name 163 Remarks 164 Customer 165 TIN No. 166 Address 0 Amount","title":"Metrobank - Debit"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#bdo-e-wallet","text":"Tender ID: 49 Requirement ID Field Name 159 Remarks 160 Customer 161 TIN No. 162 Address 0 Amount","title":"BDO E-Wallet"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#metrobank-e-wallet","text":"Tender ID: 50 Requirement ID Field Name 163 Remarks 164 Customer 165 TIN No. 166 Address 0 Amount","title":"Metrobank E-Wallet"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#tiktok","text":"Tender ID: 62 Pending Implementation: This tender type has not been implemented yet. Requirement IDs need to be provided by FullyBooked. Requirement ID Field Name TBD Order No. TBD Payment Mode TBD Courier 0 Amount","title":"TikTok"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#usage-notes","text":"","title":"Usage Notes"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#working-with-tender-requirements","text":"When modifying tender requirement mappings: Identify the Tender ID - Determine which payment method you're working with Locate Requirement IDs - Reference this document for the specific field IDs needed Update View Logic - Modify the SQL view to include/exclude requirement fields Test Thoroughly - Verify that all required fields are captured correctly","title":"Working with Tender Requirements"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#common-field-patterns","text":"Several requirement fields appear across multiple tender types: Customer Information : Customer, TIN No., Address Order Details : Order No., Payment Reference No. Shipping Information : Courier, Tracking No., Shipping Fee General : Remarks, Amount","title":"Common Field Patterns"},{"location":"projects/kwikpos-fullybooked/tender-requirements.html#adding-new-tender-types","text":"When FullyBooked introduces a new payment method: Obtain the Tender ID and all requirement field IDs from FullyBooked Add the new tender type to this documentation Update the dbo.View_tblSaleTenderRequirement view to include the new mappings Test the export with sample transactions using the new tender type","title":"Adding New Tender Types"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html","text":"This document covers known limitations and guidance for getting help with the FullyBooked integration. Known Limitations Limited Application Knowledge Limited Application Knowledge - Core application code is not well-documented here Most documentation focuses on database/SQL work rather than application architecture The WebExt application layer is not extensively covered Integration Constraints Text File Dependency - Integration relies on file-based data exchange (not real-time) Manual Processes - Some exports/imports may require manual intervention Custom Requirements - Highly specific to FullyBooked's needs, not reusable for other clients Technical Limitations File-based integration introduces latency compared to real-time API integration Manual file transfers may be required depending on deployment setup Data sync frequency depends on export/import scheduling Getting Help SQL/Database Questions What to do: Review existing views and queries in the database Check SQL Server query execution plans for performance issues Examine database schema for available tables and columns Review database logs for errors Tools: SQL Server Management Studio 19 (SSMS 19) Database documentation (if available) Data Format Issues What to do: Check with FullyBooked's technical team for format specifications Review sample files to understand expected format Validate file structure (delimiters, headers, data types) Common Issues: Tab-delimited format mismatches Missing or extra columns Data type incompatibilities Character encoding issues Export/Import Problems What to do: Review logs and validate file formats Check file permissions and access Verify file paths and transfer mechanisms Test with sample data before production Common Issues: File permission errors Path/location mismatches File format validation failures Data transformation errors New Requirements What to do: Coordinate with the development team or directly with the contact person in FullyBooked GCs Get clear specifications before making changes Document new requirements and implementation approach Test thoroughly before deployment Common Issues & Solutions Export View Not Returning Expected Data Symptoms: Missing rows in export Incorrect data values NULL values where data should exist Solutions: Review the SQL view definition Check JOIN conditions and WHERE clauses Verify source tables have the expected data Test query with sample data Check for data type conversions Import Failing with Validation Errors Symptoms: Import process fails Data type mismatch errors Constraint violation errors Solutions: Review import error logs Validate text file format matches specifications Check for data type mismatches Verify required fields are present Test import procedure with small sample file Performance Issues with Views Symptoms: Slow query execution Timeouts during export High database CPU/memory usage Solutions: Review query execution plan Add appropriate indexes Optimize JOIN operations Consider materialized views for complex queries Break large queries into smaller batches Escalation Process If you cannot resolve an issue: Document the problem - Error messages, logs, steps to reproduce Check existing documentation - Review this guide and database documentation Contact development team - For technical assistance Contact FullyBooked - For business requirement clarifications or IMS-related issues","title":"Troubleshooting"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#known-limitations","text":"","title":"Known Limitations"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#limited-application-knowledge","text":"Limited Application Knowledge - Core application code is not well-documented here Most documentation focuses on database/SQL work rather than application architecture The WebExt application layer is not extensively covered","title":"Limited Application Knowledge"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#integration-constraints","text":"Text File Dependency - Integration relies on file-based data exchange (not real-time) Manual Processes - Some exports/imports may require manual intervention Custom Requirements - Highly specific to FullyBooked's needs, not reusable for other clients","title":"Integration Constraints"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#technical-limitations","text":"File-based integration introduces latency compared to real-time API integration Manual file transfers may be required depending on deployment setup Data sync frequency depends on export/import scheduling","title":"Technical Limitations"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#getting-help","text":"","title":"Getting Help"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#sqldatabase-questions","text":"What to do: Review existing views and queries in the database Check SQL Server query execution plans for performance issues Examine database schema for available tables and columns Review database logs for errors Tools: SQL Server Management Studio 19 (SSMS 19) Database documentation (if available)","title":"SQL/Database Questions"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#data-format-issues","text":"What to do: Check with FullyBooked's technical team for format specifications Review sample files to understand expected format Validate file structure (delimiters, headers, data types) Common Issues: Tab-delimited format mismatches Missing or extra columns Data type incompatibilities Character encoding issues","title":"Data Format Issues"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#exportimport-problems","text":"What to do: Review logs and validate file formats Check file permissions and access Verify file paths and transfer mechanisms Test with sample data before production Common Issues: File permission errors Path/location mismatches File format validation failures Data transformation errors","title":"Export/Import Problems"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#new-requirements","text":"What to do: Coordinate with the development team or directly with the contact person in FullyBooked GCs Get clear specifications before making changes Document new requirements and implementation approach Test thoroughly before deployment","title":"New Requirements"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#common-issues-solutions","text":"","title":"Common Issues &amp; Solutions"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#export-view-not-returning-expected-data","text":"Symptoms: Missing rows in export Incorrect data values NULL values where data should exist Solutions: Review the SQL view definition Check JOIN conditions and WHERE clauses Verify source tables have the expected data Test query with sample data Check for data type conversions","title":"Export View Not Returning Expected Data"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#import-failing-with-validation-errors","text":"Symptoms: Import process fails Data type mismatch errors Constraint violation errors Solutions: Review import error logs Validate text file format matches specifications Check for data type mismatches Verify required fields are present Test import procedure with small sample file","title":"Import Failing with Validation Errors"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#performance-issues-with-views","text":"Symptoms: Slow query execution Timeouts during export High database CPU/memory usage Solutions: Review query execution plan Add appropriate indexes Optimize JOIN operations Consider materialized views for complex queries Break large queries into smaller batches","title":"Performance Issues with Views"},{"location":"projects/kwikpos-fullybooked/troubleshooting.html#escalation-process","text":"If you cannot resolve an issue: Document the problem - Error messages, logs, steps to reproduce Check existing documentation - Review this guide and database documentation Contact development team - For technical assistance Contact FullyBooked - For business requirement clarifications or IMS-related issues","title":"Escalation Process"},{"location":"projects/kwikpos-fullybooked/webext-installation.html","text":"You can find the installation file here: View Installer File \u2192 Note: If the installer file cannot be opened, or is not found, you can request it from our helpdesk support (Kane)","title":"WebExt Installation"},{"location":"projects/kwikpos-live/index.html","text":"Purpose: Cloud web application backend serving multiple tenant stores and branches KwikPOS Live is the central cloud-based backend system that aggregates and manages data from multiple POS terminals across different client stores and branches. It serves as the data hub for sales analytics, reporting, and multi-tenant management. Tech Stack Framework: Spring Boot 2.7.2 Runtime: Java 8 (planned upgrade to newer version) Database: MySQL 8.0 Deployment: Apache Tomcat 9.0 on AWS EC2 Deployment Method: Manual WAR file updates Database Configuration Database Schema Database Name: kwikpos_live_legacy User: root (for local development) Password: Uses your local MySQL root user password When running the project locally, the application will connect to the kwikpos_live_legacy database using the root user credentials configured on your local MySQL installation. Key Features Multi-Tenant Architecture Support for multiple clients with their branches and terminals Centralized data aggregation from individual POS terminals Tenant isolation and data security Data Management Sales data consolidation with flexible filtering Company-wide reports Branch-specific analysis Store-specific metrics Real-time data synchronization from POS terminals Analytics & Reporting Sales performance analytics Comprehensive reporting dashboard Historical data analysis Custom report generation API Services RESTful API endpoints for POS terminal communication Secure data retrieval for web dashboard Authentication and authorization mechanisms Quick Links Responsibilities - Core system responsibilities Deployment Architecture - Infrastructure and deployment details Development Setup - Local environment configuration Project Structure - Code organization and architecture Development Tasks - Common development workflows Testing - Testing strategies and practices Troubleshooting - Common issues and solutions Roadmap & Planned Work - Future features and integrations Getting Help If you encounter issues: Technical Questions: Reach out to the development team Database Issues: Contact Sophie Deployment Problems: Contact Sophie Architecture Questions: Review existing codebase patterns or consult senior developers","title":"Overview"},{"location":"projects/kwikpos-live/index.html#tech-stack","text":"Framework: Spring Boot 2.7.2 Runtime: Java 8 (planned upgrade to newer version) Database: MySQL 8.0 Deployment: Apache Tomcat 9.0 on AWS EC2 Deployment Method: Manual WAR file updates","title":"Tech Stack"},{"location":"projects/kwikpos-live/index.html#database-configuration","text":"","title":"Database Configuration"},{"location":"projects/kwikpos-live/index.html#database-schema","text":"Database Name: kwikpos_live_legacy User: root (for local development) Password: Uses your local MySQL root user password When running the project locally, the application will connect to the kwikpos_live_legacy database using the root user credentials configured on your local MySQL installation.","title":"Database Schema"},{"location":"projects/kwikpos-live/index.html#key-features","text":"","title":"Key Features"},{"location":"projects/kwikpos-live/index.html#multi-tenant-architecture","text":"Support for multiple clients with their branches and terminals Centralized data aggregation from individual POS terminals Tenant isolation and data security","title":"Multi-Tenant Architecture"},{"location":"projects/kwikpos-live/index.html#data-management","text":"Sales data consolidation with flexible filtering Company-wide reports Branch-specific analysis Store-specific metrics Real-time data synchronization from POS terminals","title":"Data Management"},{"location":"projects/kwikpos-live/index.html#analytics-reporting","text":"Sales performance analytics Comprehensive reporting dashboard Historical data analysis Custom report generation","title":"Analytics &amp; Reporting"},{"location":"projects/kwikpos-live/index.html#api-services","text":"RESTful API endpoints for POS terminal communication Secure data retrieval for web dashboard Authentication and authorization mechanisms","title":"API Services"},{"location":"projects/kwikpos-live/index.html#quick-links","text":"Responsibilities - Core system responsibilities Deployment Architecture - Infrastructure and deployment details Development Setup - Local environment configuration Project Structure - Code organization and architecture Development Tasks - Common development workflows Testing - Testing strategies and practices Troubleshooting - Common issues and solutions Roadmap & Planned Work - Future features and integrations","title":"Quick Links"},{"location":"projects/kwikpos-live/index.html#getting-help","text":"If you encounter issues: Technical Questions: Reach out to the development team Database Issues: Contact Sophie Deployment Problems: Contact Sophie Architecture Questions: Review existing codebase patterns or consult senior developers","title":"Getting Help"},{"location":"projects/kwikpos-live/deployment.html","text":"Infrastructure Hosting: AWS EC2 instance Application Server: Apache Tomcat 9.0 servlet container Database: Direct MySQL 8.0 database connection Deployment Pipeline Current Method Legacy manual WAR deployment Process Build WAR file using Maven Manual upload to EC2 instance Deploy to Tomcat webapps directory Restart Tomcat service Configuration Environment-specific configuration files Database connection pooling Security settings and credentials management","title":"Deployment Architecture"},{"location":"projects/kwikpos-live/deployment.html#infrastructure","text":"Hosting: AWS EC2 instance Application Server: Apache Tomcat 9.0 servlet container Database: Direct MySQL 8.0 database connection","title":"Infrastructure"},{"location":"projects/kwikpos-live/deployment.html#deployment-pipeline","text":"","title":"Deployment Pipeline"},{"location":"projects/kwikpos-live/deployment.html#current-method","text":"Legacy manual WAR deployment","title":"Current Method"},{"location":"projects/kwikpos-live/deployment.html#process","text":"Build WAR file using Maven Manual upload to EC2 instance Deploy to Tomcat webapps directory Restart Tomcat service","title":"Process"},{"location":"projects/kwikpos-live/deployment.html#configuration","text":"Environment-specific configuration files Database connection pooling Security settings and credentials management","title":"Configuration"},{"location":"projects/kwikpos-live/development.html","text":"Adding New Features Create feature branch from main, separated by dashes. (ex. feature-add-something ) Implement changes following existing patterns Write unit tests Test locally with MySQL database Submit pull request for code review Warning: Do not commit and push the application.properties in source control for this project as it contains sensitive keys and etc. unlike the KwikPOS API project which uses profile-specific properties files. Database Changes Create migration SQL DDL scripts Test on local database Document changes Coordinate with team for production deployment API Development Define endpoint in appropriate controller Implement service layer logic Add repository methods if needed Document API using comments or Swagger Test with Postman Best Practices Follow existing code patterns and conventions Write meaningful commit messages Keep pull requests focused and manageable Document complex logic with comments Update tests when changing functionality","title":"Development Tasks"},{"location":"projects/kwikpos-live/development.html#adding-new-features","text":"Create feature branch from main, separated by dashes. (ex. feature-add-something ) Implement changes following existing patterns Write unit tests Test locally with MySQL database Submit pull request for code review Warning: Do not commit and push the application.properties in source control for this project as it contains sensitive keys and etc. unlike the KwikPOS API project which uses profile-specific properties files.","title":"Adding New Features"},{"location":"projects/kwikpos-live/development.html#database-changes","text":"Create migration SQL DDL scripts Test on local database Document changes Coordinate with team for production deployment","title":"Database Changes"},{"location":"projects/kwikpos-live/development.html#api-development","text":"Define endpoint in appropriate controller Implement service layer logic Add repository methods if needed Document API using comments or Swagger Test with Postman","title":"API Development"},{"location":"projects/kwikpos-live/development.html#best-practices","text":"Follow existing code patterns and conventions Write meaningful commit messages Keep pull requests focused and manageable Document complex logic with comments Update tests when changing functionality","title":"Best Practices"},{"location":"projects/kwikpos-live/responsibilities.html","text":"Data Reception Accepts data from POS terminals across all client stores via REST API Validates and processes incoming sales records Handles real-time data synchronization Data Storage Serves as the central data repository for sales records Maintains data integrity and consistency Provides efficient data retrieval mechanisms Backend Services Provides backend services for the KwikPOS Live web application Handles business logic for multi-tenant operations Manages user authentication and authorization Analytics Processing Processes data for sales analytics and reporting Generates aggregated statistics Supports complex querying and filtering","title":"Responsibilities"},{"location":"projects/kwikpos-live/responsibilities.html#data-reception","text":"Accepts data from POS terminals across all client stores via REST API Validates and processes incoming sales records Handles real-time data synchronization","title":"Data Reception"},{"location":"projects/kwikpos-live/responsibilities.html#data-storage","text":"Serves as the central data repository for sales records Maintains data integrity and consistency Provides efficient data retrieval mechanisms","title":"Data Storage"},{"location":"projects/kwikpos-live/responsibilities.html#backend-services","text":"Provides backend services for the KwikPOS Live web application Handles business logic for multi-tenant operations Manages user authentication and authorization","title":"Backend Services"},{"location":"projects/kwikpos-live/responsibilities.html#analytics-processing","text":"Processes data for sales analytics and reporting Generates aggregated statistics Supports complex querying and filtering","title":"Analytics Processing"},{"location":"projects/kwikpos-live/roadmap.html","text":"This document outlines planned features, integrations, and improvements for KwikPOS Live. These items represent future work that needs to be implemented. Planned Integrations KwikPOS Pro Data Sync Integration Priority: High Status: Planned Description: Integration to enable KwikPOS Pro (our new POS product) to send sales data and transactions to the KwikPOS Live cloud backend. This follows the same pattern as the existing legacy POS integration but needs to be implemented on the KwikPOS Pro side. Current State: Legacy Chase POS already syncs data to KwikPOS Live cloud Sync endpoints are already available and ready on KwikPOS Live backend KwikPOS Pro team needs to implement the client-side integration to call these endpoints Requirements: KwikPOS Pro must implement API calls to existing sync endpoints Sales data, transactions, and inventory movements need to be sent to cloud Real-time or near-real-time synchronization preferred Handle offline scenarios (queue data when offline, sync when online) Implementation Notes: Backend (KwikPOS Live) side: Sync endpoints already exist and are ready Frontend (KwikPOS Pro) side: Team needs to hook up their POS to call these endpoints This is primarily a KwikPOS Pro development task KwikPOS Live team may need to provide endpoint documentation and support Responsibilities: KwikPOS Live Backend: Maintain and support existing sync endpoints KwikPOS Pro Team: Implement the actual integration and sync logic in their POS application Resources: Existing sync endpoint documentation (to be provided to KwikPOS Pro team) Legacy POS integration as reference implementation API specifications for data format and authentication Notes: Coordination with KwikPOS Pro development team is essential May need to schedule knowledge transfer sessions Ensure KwikPOS Pro team has access to API documentation Inventory Syncing Integration Priority: High Status: Planned Description: Enable inventory data synchronization between POS terminals and the cloud backend. This will allow centralized inventory tracking and management across multiple stores and branches. Current State: Requirements not fully defined yet Inventory management planned as a future cloud feature Need to determine sync frequency, conflict resolution, and data flow Requirements: TBD - Requirements gathering needed Inventory levels sync from POS to cloud Potentially bidirectional sync (cloud to POS for centralized inventory management) Conflict resolution strategy for inventory discrepancies Implementation Notes: Coordinate with product team to gather detailed requirements Determine if this is real-time or batch synchronization Design database schema for inventory data if not already present Consider multi-tenant implications for inventory tracking Next Steps: Requirements gathering with stakeholders Technical design based on requirements Implementation plan and timeline Notes: Requirements are still being defined - not enough details available yet This may be part of the larger inventory management feature Planned Features AI-Powered Sales Reports and Forecasting Priority: Medium Status: Planned Description: Implement AI-powered analytics features including intelligent sales reports, sales forecasting, trend analysis, and predictive insights to help clients make better business decisions. User Stories: As a restaurant owner, I want to see sales forecasts so that I can plan inventory and staffing As a manager, I want AI-generated insights on sales trends so that I can identify growth opportunities As a business analyst, I want predictive reports so that I can make data-driven decisions Technical Approach: Integrate AI/ML models for sales prediction and forecasting Use historical sales data to train forecasting models Implement trend analysis algorithms Create new API endpoints for AI-generated reports Design dashboard UI for displaying AI insights Potential Technologies: Machine learning libraries (TensorFlow, scikit-learn, or similar) Time series forecasting models (ARIMA, Prophet, LSTM) XGBoost machine learning tool for sales forecasting May require integration with external AI services or in-house model development Acceptance Criteria: Sales forecasting with reasonable accuracy based on historical data Trend detection and anomaly identification AI-generated insights and recommendations User-friendly visualization of forecasts and predictions Performance is acceptable (reports generate in reasonable time) Resources: Historical sales data for training Business requirements for specific insights needed UI/UX designs for report presentation Notes: May require data science expertise Consider privacy and data security for AI processing Evaluate build vs. buy for AI capabilities Cloud-Based Inventory Management System Priority: High Status: Planned Description: Build a comprehensive cloud-based inventory management system that leverages the multi-tenant architecture to provide centralized inventory tracking, management, and reporting across multiple stores and branches. Planned Timeline: February 2026 User Stories: As a multi-branch owner, I want to manage inventory centrally so that I can track stock across all locations As a store manager, I want to see real-time inventory levels so that I can avoid stockouts As a warehouse manager, I want to track inventory movements so that I can optimize stock distribution Technical Approach: Design database schema for inventory items, stock levels, and movements Implement CRUD APIs for inventory management Build real-time inventory tracking with sync from POS terminals Create inventory reporting and analytics features Develop multi-tenant inventory access controls (each tenant sees only their inventory) Build UI for inventory management dashboard Key Features: Item master data management (SKU, descriptions, categories) Stock level tracking per location/branch Inventory movement tracking (receipts, transfers, adjustments) Low stock alerts and notifications Inventory reports (stock levels, movement history, valuation) Multi-location inventory visibility Acceptance Criteria: Centralized inventory database with multi-tenant support Real-time or near-real-time inventory sync from POS Inventory reports accessible via web dashboard Role-based access control for inventory management Performance handles multiple stores and thousands of items Resources: Business requirements document UI/UX designs for inventory dashboard Integration specifications with POS systems Notes: Target Date: February 2026 Coordinate with POS teams for inventory sync integration Consider scalability for large inventories May need data migration for existing inventory data Known Issues & Tech Debt Spring Boot and Java Version Upgrade Priority: High Status: Planned Description: Upgrade from Spring Boot 2.7.2 and Java 8 to Spring Boot 3.x and Java 17 LTS to stay on supported versions, improve performance, security, and access newer framework features. Current State: Running on Spring Boot 2.7.2 with Java 8 Java 8 is no longer receiving public updates (EOL) Spring Boot 2.x will eventually lose support Missing out on performance improvements and modern Java features Impact: Security vulnerabilities in older Java versions Missing performance optimizations in newer JVMs Unable to use modern Spring Boot 3.x features Potential dependency compatibility issues over time Difficulty hiring developers familiar with old tech stack Proposed Solution: Upgrade to Java 17 LTS (current long-term support version) Migrate to Spring Boot 3.x (latest stable version) Update dependencies to compatible versions Test thoroughly to ensure no breaking changes Plan phased rollout to minimize risk Migration Steps: Audit current dependencies and identify compatibility issues Set up local development environment with Java 17 Update Spring Boot to 3.x in a separate branch Fix breaking changes and deprecated API usage Update all dependencies to Spring Boot 3.x compatible versions Comprehensive testing (unit, integration, end-to-end) Performance testing and optimization Staged deployment (dev \u2192 staging \u2192 production) Risks/Considerations: Breaking changes in Spring Boot 3.x (e.g., Jakarta EE namespace changes) Potential API incompatibilities with dependencies Need thorough regression testing May require code refactoring Deployment downtime considerations Effort Estimate: Medium to Large (several weeks of development and testing) Testing Requirements: Full regression testing of all endpoints Integration testing with POS systems Performance benchmarking Security testing User acceptance testing Notes: This is technical debt that should be addressed sooner rather than later Java 8 EOL creates security and compliance risks Coordinate with team for development schedule Consider doing in phases to reduce risk Notes for Future Developers General Context KwikPOS Live serves as the central cloud backend for our POS ecosystem. It aggregates sales data from multiple POS terminals across different client stores and branches, providing analytics and reporting capabilities through a multi-tenant architecture. Key Contacts Developer: Sophie KwikPOS Pro Development Team: For POS integration coordination Things to Keep in Mind This is a multi-tenant system - always ensure tenant data isolation Performance is critical for real-time data syncing from multiple POS terminals Coordinate with POS teams (Legacy and KwikPOS Pro) for any API changes Database migrations must be carefully planned due to production data AWS infrastructure changes should be documented and coordinated Timeline & Prioritization Q1 2026 (January - March) Cloud-Based Inventory Management - Target: February 2026 Database schema design and implementation Core inventory APIs development Basic inventory dashboard UI Integration with POS systems for inventory sync Q2 2026 (April - June) AI-Powered Sales Reports and Forecasting - Timeline TBD Requirements finalization AI model selection and integration Report generation APIs Dashboard UI for AI insights Future (No Specific Timeline) Spring Boot and Java Version Upgrade - Schedule TBD Dependency audit and upgrade planning Development and testing Phased deployment KwikPOS Pro Sync Integration - Dependent on KwikPOS Pro team Primarily KwikPOS Pro team responsibility KwikPOS Live team provides endpoint support Inventory Syncing Integration - Requirements pending Requirements gathering Technical design Implementation Ongoing Bug fixes and technical improvements as identified Performance optimizations Security updates and patches Support for existing integrations","title":"Roadmap & Planned Work"},{"location":"projects/kwikpos-live/roadmap.html#planned-integrations","text":"","title":"Planned Integrations"},{"location":"projects/kwikpos-live/roadmap.html#kwikpos-pro-data-sync-integration","text":"Priority: High Status: Planned Description: Integration to enable KwikPOS Pro (our new POS product) to send sales data and transactions to the KwikPOS Live cloud backend. This follows the same pattern as the existing legacy POS integration but needs to be implemented on the KwikPOS Pro side. Current State: Legacy Chase POS already syncs data to KwikPOS Live cloud Sync endpoints are already available and ready on KwikPOS Live backend KwikPOS Pro team needs to implement the client-side integration to call these endpoints Requirements: KwikPOS Pro must implement API calls to existing sync endpoints Sales data, transactions, and inventory movements need to be sent to cloud Real-time or near-real-time synchronization preferred Handle offline scenarios (queue data when offline, sync when online) Implementation Notes: Backend (KwikPOS Live) side: Sync endpoints already exist and are ready Frontend (KwikPOS Pro) side: Team needs to hook up their POS to call these endpoints This is primarily a KwikPOS Pro development task KwikPOS Live team may need to provide endpoint documentation and support Responsibilities: KwikPOS Live Backend: Maintain and support existing sync endpoints KwikPOS Pro Team: Implement the actual integration and sync logic in their POS application Resources: Existing sync endpoint documentation (to be provided to KwikPOS Pro team) Legacy POS integration as reference implementation API specifications for data format and authentication Notes: Coordination with KwikPOS Pro development team is essential May need to schedule knowledge transfer sessions Ensure KwikPOS Pro team has access to API documentation","title":"KwikPOS Pro Data Sync Integration"},{"location":"projects/kwikpos-live/roadmap.html#inventory-syncing-integration","text":"Priority: High Status: Planned Description: Enable inventory data synchronization between POS terminals and the cloud backend. This will allow centralized inventory tracking and management across multiple stores and branches. Current State: Requirements not fully defined yet Inventory management planned as a future cloud feature Need to determine sync frequency, conflict resolution, and data flow Requirements: TBD - Requirements gathering needed Inventory levels sync from POS to cloud Potentially bidirectional sync (cloud to POS for centralized inventory management) Conflict resolution strategy for inventory discrepancies Implementation Notes: Coordinate with product team to gather detailed requirements Determine if this is real-time or batch synchronization Design database schema for inventory data if not already present Consider multi-tenant implications for inventory tracking Next Steps: Requirements gathering with stakeholders Technical design based on requirements Implementation plan and timeline Notes: Requirements are still being defined - not enough details available yet This may be part of the larger inventory management feature","title":"Inventory Syncing Integration"},{"location":"projects/kwikpos-live/roadmap.html#planned-features","text":"","title":"Planned Features"},{"location":"projects/kwikpos-live/roadmap.html#ai-powered-sales-reports-and-forecasting","text":"Priority: Medium Status: Planned Description: Implement AI-powered analytics features including intelligent sales reports, sales forecasting, trend analysis, and predictive insights to help clients make better business decisions. User Stories: As a restaurant owner, I want to see sales forecasts so that I can plan inventory and staffing As a manager, I want AI-generated insights on sales trends so that I can identify growth opportunities As a business analyst, I want predictive reports so that I can make data-driven decisions Technical Approach: Integrate AI/ML models for sales prediction and forecasting Use historical sales data to train forecasting models Implement trend analysis algorithms Create new API endpoints for AI-generated reports Design dashboard UI for displaying AI insights Potential Technologies: Machine learning libraries (TensorFlow, scikit-learn, or similar) Time series forecasting models (ARIMA, Prophet, LSTM) XGBoost machine learning tool for sales forecasting May require integration with external AI services or in-house model development Acceptance Criteria: Sales forecasting with reasonable accuracy based on historical data Trend detection and anomaly identification AI-generated insights and recommendations User-friendly visualization of forecasts and predictions Performance is acceptable (reports generate in reasonable time) Resources: Historical sales data for training Business requirements for specific insights needed UI/UX designs for report presentation Notes: May require data science expertise Consider privacy and data security for AI processing Evaluate build vs. buy for AI capabilities","title":"AI-Powered Sales Reports and Forecasting"},{"location":"projects/kwikpos-live/roadmap.html#cloud-based-inventory-management-system","text":"Priority: High Status: Planned Description: Build a comprehensive cloud-based inventory management system that leverages the multi-tenant architecture to provide centralized inventory tracking, management, and reporting across multiple stores and branches. Planned Timeline: February 2026 User Stories: As a multi-branch owner, I want to manage inventory centrally so that I can track stock across all locations As a store manager, I want to see real-time inventory levels so that I can avoid stockouts As a warehouse manager, I want to track inventory movements so that I can optimize stock distribution Technical Approach: Design database schema for inventory items, stock levels, and movements Implement CRUD APIs for inventory management Build real-time inventory tracking with sync from POS terminals Create inventory reporting and analytics features Develop multi-tenant inventory access controls (each tenant sees only their inventory) Build UI for inventory management dashboard Key Features: Item master data management (SKU, descriptions, categories) Stock level tracking per location/branch Inventory movement tracking (receipts, transfers, adjustments) Low stock alerts and notifications Inventory reports (stock levels, movement history, valuation) Multi-location inventory visibility Acceptance Criteria: Centralized inventory database with multi-tenant support Real-time or near-real-time inventory sync from POS Inventory reports accessible via web dashboard Role-based access control for inventory management Performance handles multiple stores and thousands of items Resources: Business requirements document UI/UX designs for inventory dashboard Integration specifications with POS systems Notes: Target Date: February 2026 Coordinate with POS teams for inventory sync integration Consider scalability for large inventories May need data migration for existing inventory data","title":"Cloud-Based Inventory Management System"},{"location":"projects/kwikpos-live/roadmap.html#known-issues-tech-debt","text":"","title":"Known Issues &amp; Tech Debt"},{"location":"projects/kwikpos-live/roadmap.html#spring-boot-and-java-version-upgrade","text":"Priority: High Status: Planned Description: Upgrade from Spring Boot 2.7.2 and Java 8 to Spring Boot 3.x and Java 17 LTS to stay on supported versions, improve performance, security, and access newer framework features. Current State: Running on Spring Boot 2.7.2 with Java 8 Java 8 is no longer receiving public updates (EOL) Spring Boot 2.x will eventually lose support Missing out on performance improvements and modern Java features Impact: Security vulnerabilities in older Java versions Missing performance optimizations in newer JVMs Unable to use modern Spring Boot 3.x features Potential dependency compatibility issues over time Difficulty hiring developers familiar with old tech stack Proposed Solution: Upgrade to Java 17 LTS (current long-term support version) Migrate to Spring Boot 3.x (latest stable version) Update dependencies to compatible versions Test thoroughly to ensure no breaking changes Plan phased rollout to minimize risk Migration Steps: Audit current dependencies and identify compatibility issues Set up local development environment with Java 17 Update Spring Boot to 3.x in a separate branch Fix breaking changes and deprecated API usage Update all dependencies to Spring Boot 3.x compatible versions Comprehensive testing (unit, integration, end-to-end) Performance testing and optimization Staged deployment (dev \u2192 staging \u2192 production) Risks/Considerations: Breaking changes in Spring Boot 3.x (e.g., Jakarta EE namespace changes) Potential API incompatibilities with dependencies Need thorough regression testing May require code refactoring Deployment downtime considerations Effort Estimate: Medium to Large (several weeks of development and testing) Testing Requirements: Full regression testing of all endpoints Integration testing with POS systems Performance benchmarking Security testing User acceptance testing Notes: This is technical debt that should be addressed sooner rather than later Java 8 EOL creates security and compliance risks Coordinate with team for development schedule Consider doing in phases to reduce risk","title":"Spring Boot and Java Version Upgrade"},{"location":"projects/kwikpos-live/roadmap.html#notes-for-future-developers","text":"","title":"Notes for Future Developers"},{"location":"projects/kwikpos-live/roadmap.html#general-context","text":"KwikPOS Live serves as the central cloud backend for our POS ecosystem. It aggregates sales data from multiple POS terminals across different client stores and branches, providing analytics and reporting capabilities through a multi-tenant architecture.","title":"General Context"},{"location":"projects/kwikpos-live/roadmap.html#key-contacts","text":"Developer: Sophie KwikPOS Pro Development Team: For POS integration coordination","title":"Key Contacts"},{"location":"projects/kwikpos-live/roadmap.html#things-to-keep-in-mind","text":"This is a multi-tenant system - always ensure tenant data isolation Performance is critical for real-time data syncing from multiple POS terminals Coordinate with POS teams (Legacy and KwikPOS Pro) for any API changes Database migrations must be carefully planned due to production data AWS infrastructure changes should be documented and coordinated","title":"Things to Keep in Mind"},{"location":"projects/kwikpos-live/roadmap.html#timeline-prioritization","text":"","title":"Timeline &amp; Prioritization"},{"location":"projects/kwikpos-live/roadmap.html#q1-2026-january-march","text":"Cloud-Based Inventory Management - Target: February 2026 Database schema design and implementation Core inventory APIs development Basic inventory dashboard UI Integration with POS systems for inventory sync","title":"Q1 2026 (January - March)"},{"location":"projects/kwikpos-live/roadmap.html#q2-2026-april-june","text":"AI-Powered Sales Reports and Forecasting - Timeline TBD Requirements finalization AI model selection and integration Report generation APIs Dashboard UI for AI insights","title":"Q2 2026 (April - June)"},{"location":"projects/kwikpos-live/roadmap.html#future-no-specific-timeline","text":"Spring Boot and Java Version Upgrade - Schedule TBD Dependency audit and upgrade planning Development and testing Phased deployment KwikPOS Pro Sync Integration - Dependent on KwikPOS Pro team Primarily KwikPOS Pro team responsibility KwikPOS Live team provides endpoint support Inventory Syncing Integration - Requirements pending Requirements gathering Technical design Implementation","title":"Future (No Specific Timeline)"},{"location":"projects/kwikpos-live/roadmap.html#ongoing","text":"Bug fixes and technical improvements as identified Performance optimizations Security updates and patches Support for existing integrations","title":"Ongoing"},{"location":"projects/kwikpos-live/setup.html","text":"Prerequisites Refer to Prerequisites for detailed requirements. For KwikPOS Live, you need: JDK 8 Maven 3.6+ MySQL 8.0 Apache Tomcat 9.0 (for local testing) Git Local Setup Steps 1. Clone the Repository git clone https://github.com/oct-ph/kwikpos-live-legacy-backend.git cd kwikpos-live-legacy-backend 2. Request for the Application Properties File The project utilizes an application.properties file which holds all of the necessary project configurations. The spring boot application will not run without this. We additionally excluded this from source control as it doesn't use profiles unlike the project for KwikPOS API. 3. Request for the Dumped Data for Local Testing then Import via MySQL Workbench 8.0 This step would be crucial in order to setup your own database to use for local development and testing. Warning: Avoid testing in production environment. 4. Update Configuration Edit the application.properties file and configure database connection: spring.datasource.url=jdbc:mysql://localhost:3306/kwikpos_live_legacy spring.datasource.username=your_username spring.datasource.password=your_password Warning: Do not commit and push the application.properties in source control for this project as it contains sensitive keys and etc. unlike the KwikPOS API project which uses profile-specific properties files. 5. Build the Project mvn clean install 6. Run Locally # Using Spring Boot mvn spring-boot:run 7. Verify Installation Access via http://localhost:8082 Test API endpoints using Postman Additional Resources Spring Boot 2.7.2 Documentation MySQL 8.0 Reference Manual Apache Tomcat 9.0 Documentation Internal API documentation (if available)","title":"Development Setup"},{"location":"projects/kwikpos-live/setup.html#prerequisites","text":"Refer to Prerequisites for detailed requirements. For KwikPOS Live, you need: JDK 8 Maven 3.6+ MySQL 8.0 Apache Tomcat 9.0 (for local testing) Git","title":"Prerequisites"},{"location":"projects/kwikpos-live/setup.html#local-setup-steps","text":"","title":"Local Setup Steps"},{"location":"projects/kwikpos-live/setup.html#1-clone-the-repository","text":"git clone https://github.com/oct-ph/kwikpos-live-legacy-backend.git cd kwikpos-live-legacy-backend","title":"1. Clone the Repository"},{"location":"projects/kwikpos-live/setup.html#2-request-for-the-application-properties-file","text":"The project utilizes an application.properties file which holds all of the necessary project configurations. The spring boot application will not run without this. We additionally excluded this from source control as it doesn't use profiles unlike the project for KwikPOS API.","title":"2. Request for the Application Properties File"},{"location":"projects/kwikpos-live/setup.html#3-request-for-the-dumped-data-for-local-testing-then-import-via-mysql-workbench-80","text":"This step would be crucial in order to setup your own database to use for local development and testing. Warning: Avoid testing in production environment.","title":"3. Request for the Dumped Data for Local Testing then Import via MySQL Workbench 8.0"},{"location":"projects/kwikpos-live/setup.html#4-update-configuration","text":"Edit the application.properties file and configure database connection: spring.datasource.url=jdbc:mysql://localhost:3306/kwikpos_live_legacy spring.datasource.username=your_username spring.datasource.password=your_password Warning: Do not commit and push the application.properties in source control for this project as it contains sensitive keys and etc. unlike the KwikPOS API project which uses profile-specific properties files.","title":"4. Update Configuration"},{"location":"projects/kwikpos-live/setup.html#5-build-the-project","text":"mvn clean install","title":"5. Build the Project"},{"location":"projects/kwikpos-live/setup.html#6-run-locally","text":"# Using Spring Boot mvn spring-boot:run","title":"6. Run Locally"},{"location":"projects/kwikpos-live/setup.html#7-verify-installation","text":"Access via http://localhost:8082 Test API endpoints using Postman","title":"7. Verify Installation"},{"location":"projects/kwikpos-live/setup.html#additional-resources","text":"Spring Boot 2.7.2 Documentation MySQL 8.0 Reference Manual Apache Tomcat 9.0 Documentation Internal API documentation (if available)","title":"Additional Resources"},{"location":"projects/kwikpos-live/structure.html","text":"kwikpos-live-legacy-backend/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main/ \u2502 \u2502 \u251c\u2500\u2500 java/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 com/oneclicktech/spring/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 component/ # Component classes \u2502 \u2502 \u2502 \u251c\u2500\u2500 config/ # Configuration classes \u2502 \u2502 \u2502 \u251c\u2500\u2500 controller/ # REST controllers \u2502 \u2502 \u2502 \u251c\u2500\u2500 dto/ # Data transfer objects \u2502 \u2502 \u2502 \u251c\u2500\u2500 enums/ # Enum objects \u2502 \u2502 \u2502 \u251c\u2500\u2500 login/ # Authentication & security classes \u2502 \u2502 \u2502 \u251c\u2500\u2500 mapper/ # Mapper interface methods \u2502 \u2502 \u2502 \u251c\u2500\u2500 model/ # Entity models and constants \u2502 \u2502 \u2502 \u2514\u2500\u2500 service/ # Business logic \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources/ \u2502 \u2502 \u251c\u2500\u2500 application.properties \u2502 \u2502 \u2514\u2500\u2500 email_templates/ # Templates for email services \u2502 \u2502 \u2502 \u2514\u2500\u2500 test/ # Unit and integration tests \u251c\u2500\u2500 pom.xml # Maven configuration \u2514\u2500\u2500 README.md Package Overview component/ Component classes for cross-cutting concerns and utilities that can be injected and reused across the application. config/ Configuration classes for Spring Boot, security, database connections, and other application settings. controller/ REST controllers that handle HTTP requests and responses. Each controller typically corresponds to a specific domain or feature area. dto/ Data Transfer Objects used for API requests and responses, separating internal models from external representations. enums/ Enum objects that define fixed sets of constants used throughout the application for type-safe value representation. login/ Authentication and security classes that handle user login, session management, and security-related functionality. mapper/ MyBatis mapper interfaces that define SQL query methods for database operations. model/ Entity models representing database tables and constant values used throughout the application. service/ Business logic layer that implements the core functionality. Services are called by controllers and interact with mappers.","title":"Project Structure"},{"location":"projects/kwikpos-live/structure.html#package-overview","text":"","title":"Package Overview"},{"location":"projects/kwikpos-live/structure.html#component","text":"Component classes for cross-cutting concerns and utilities that can be injected and reused across the application.","title":"component/"},{"location":"projects/kwikpos-live/structure.html#config","text":"Configuration classes for Spring Boot, security, database connections, and other application settings.","title":"config/"},{"location":"projects/kwikpos-live/structure.html#controller","text":"REST controllers that handle HTTP requests and responses. Each controller typically corresponds to a specific domain or feature area.","title":"controller/"},{"location":"projects/kwikpos-live/structure.html#dto","text":"Data Transfer Objects used for API requests and responses, separating internal models from external representations.","title":"dto/"},{"location":"projects/kwikpos-live/structure.html#enums","text":"Enum objects that define fixed sets of constants used throughout the application for type-safe value representation.","title":"enums/"},{"location":"projects/kwikpos-live/structure.html#login","text":"Authentication and security classes that handle user login, session management, and security-related functionality.","title":"login/"},{"location":"projects/kwikpos-live/structure.html#mapper","text":"MyBatis mapper interfaces that define SQL query methods for database operations.","title":"mapper/"},{"location":"projects/kwikpos-live/structure.html#model","text":"Entity models representing database tables and constant values used throughout the application.","title":"model/"},{"location":"projects/kwikpos-live/structure.html#service","text":"Business logic layer that implements the core functionality. Services are called by controllers and interact with mappers.","title":"service/"},{"location":"projects/kwikpos-live/testing.html","text":"Local Testing Run All Tests mvn test Run Specific Test Class mvn test -Dtest=YourTestClass Run Integration Tests mvn verify Manual Testing Use Postman collections for API testing Test multi-tenant scenarios Verify data consistency Always try to locally test changes to your own database before production Testing Checklist When testing new features or changes: Manual API testing with Postman Multi-tenant scenarios verified Database changes tested locally before implementing on production Error handling tested Edge cases considered","title":"Testing"},{"location":"projects/kwikpos-live/testing.html#local-testing","text":"","title":"Local Testing"},{"location":"projects/kwikpos-live/testing.html#run-all-tests","text":"mvn test","title":"Run All Tests"},{"location":"projects/kwikpos-live/testing.html#run-specific-test-class","text":"mvn test -Dtest=YourTestClass","title":"Run Specific Test Class"},{"location":"projects/kwikpos-live/testing.html#run-integration-tests","text":"mvn verify","title":"Run Integration Tests"},{"location":"projects/kwikpos-live/testing.html#manual-testing","text":"Use Postman collections for API testing Test multi-tenant scenarios Verify data consistency Always try to locally test changes to your own database before production","title":"Manual Testing"},{"location":"projects/kwikpos-live/testing.html#testing-checklist","text":"When testing new features or changes: Manual API testing with Postman Multi-tenant scenarios verified Database changes tested locally before implementing on production Error handling tested Edge cases considered","title":"Testing Checklist"},{"location":"projects/kwikpos-live/troubleshooting.html","text":"Common Issues Build Failures Symptoms: Maven build fails or produces errors Solutions: Verify JDK 8 is active: java -version Clean Maven cache: mvn clean Update dependencies: mvn dependency:resolve Database Connection Issues Symptoms: Cannot connect to MySQL database Solutions: Check MySQL service is running Verify credentials in application.properties Ensure database exists Test connection using MySQL Workbench Tomcat Deployment Issues Symptoms: Application fails to deploy or start on Tomcat Solutions: Check Tomcat logs in logs/catalina.out Verify WAR file is not corrupted Ensure port 8080 ( or the configured port ) is available Confirm Tomcat version is 9.0 Login Issues (Production) Symptoms: Users suddenly unable to login despite application working hours earlier Possible Causes & Solutions: 1. Expired SSL Certificate Symptoms: Login was working previously but suddenly stopped Browser shows SSL/certificate errors HTTPS connections failing Solutions: Check SSL certificate expiration date Verify certificate is valid and not expired Action Required: Report expired SSL certificate immediately to the infrastructure team Renew SSL certificate through AWS Certificate Manager or certificate provider Update certificate on the load balancer/server How to Check: For the safest way without using any command line terminals, you may simply go into the website itself for KwikPOS Live and inspect the SSL certificate there. 2. EC2 Storage Full ( Most Common ) Symptoms: Application becomes unresponsive Login attempts fail or timeout Logs show disk space errors Services fail to start or write data Solutions: Connect to EC2 instance via RDP Check disk space usage on C: drive (or applicable drive) Clear temporary files and logs if storage is full Identify large files consuming space, most of the time it's related to log files or any past dump files Archive or delete old log files (retain only logs from the last 5 days) Consider increasing EBS volume size if consistently running out of space How to Check Storage via RDP: Connect to EC2 instance using Remote Desktop Protocol (RDP) Open File Explorer Right-click on C: drive \u2192 Properties Check available space If space is critically low (< 10% free): Navigate to application logs directory Archive or delete old log files Clear Windows temp folder: C:\\Windows\\Temp Check Tomcat logs: <TOMCAT_HOME>\\logs Preventive Measures: Set up CloudWatch alarms for disk space monitoring Implement log rotation policies Regularly clean up temporary files Monitor storage usage trends Action Required: Report storage issues to infrastructure/DevOps team Document which logs or files were consuming space Consider implementing automated log cleanup or rotation Getting Additional Help If issues persist: Technical Questions: Reach out to the development team Database Issues: Contact Sophie Deployment Problems: Contact Sophie Architecture Questions: Review existing codebase patterns or consult senior developers","title":"Troubleshooting"},{"location":"projects/kwikpos-live/troubleshooting.html#common-issues","text":"","title":"Common Issues"},{"location":"projects/kwikpos-live/troubleshooting.html#build-failures","text":"Symptoms: Maven build fails or produces errors Solutions: Verify JDK 8 is active: java -version Clean Maven cache: mvn clean Update dependencies: mvn dependency:resolve","title":"Build Failures"},{"location":"projects/kwikpos-live/troubleshooting.html#database-connection-issues","text":"Symptoms: Cannot connect to MySQL database Solutions: Check MySQL service is running Verify credentials in application.properties Ensure database exists Test connection using MySQL Workbench","title":"Database Connection Issues"},{"location":"projects/kwikpos-live/troubleshooting.html#tomcat-deployment-issues","text":"Symptoms: Application fails to deploy or start on Tomcat Solutions: Check Tomcat logs in logs/catalina.out Verify WAR file is not corrupted Ensure port 8080 ( or the configured port ) is available Confirm Tomcat version is 9.0","title":"Tomcat Deployment Issues"},{"location":"projects/kwikpos-live/troubleshooting.html#login-issues-production","text":"Symptoms: Users suddenly unable to login despite application working hours earlier Possible Causes & Solutions:","title":"Login Issues (Production)"},{"location":"projects/kwikpos-live/troubleshooting.html#1-expired-ssl-certificate","text":"Symptoms: Login was working previously but suddenly stopped Browser shows SSL/certificate errors HTTPS connections failing Solutions: Check SSL certificate expiration date Verify certificate is valid and not expired Action Required: Report expired SSL certificate immediately to the infrastructure team Renew SSL certificate through AWS Certificate Manager or certificate provider Update certificate on the load balancer/server How to Check: For the safest way without using any command line terminals, you may simply go into the website itself for KwikPOS Live and inspect the SSL certificate there.","title":"1. Expired SSL Certificate"},{"location":"projects/kwikpos-live/troubleshooting.html#2-ec2-storage-full-most-common","text":"Symptoms: Application becomes unresponsive Login attempts fail or timeout Logs show disk space errors Services fail to start or write data Solutions: Connect to EC2 instance via RDP Check disk space usage on C: drive (or applicable drive) Clear temporary files and logs if storage is full Identify large files consuming space, most of the time it's related to log files or any past dump files Archive or delete old log files (retain only logs from the last 5 days) Consider increasing EBS volume size if consistently running out of space How to Check Storage via RDP: Connect to EC2 instance using Remote Desktop Protocol (RDP) Open File Explorer Right-click on C: drive \u2192 Properties Check available space If space is critically low (< 10% free): Navigate to application logs directory Archive or delete old log files Clear Windows temp folder: C:\\Windows\\Temp Check Tomcat logs: <TOMCAT_HOME>\\logs Preventive Measures: Set up CloudWatch alarms for disk space monitoring Implement log rotation policies Regularly clean up temporary files Monitor storage usage trends Action Required: Report storage issues to infrastructure/DevOps team Document which logs or files were consuming space Consider implementing automated log cleanup or rotation","title":"2. EC2 Storage Full (Most Common)"},{"location":"projects/kwikpos-live/troubleshooting.html#getting-additional-help","text":"If issues persist: Technical Questions: Reach out to the development team Database Issues: Contact Sophie Deployment Problems: Contact Sophie Architecture Questions: Review existing codebase patterns or consult senior developers","title":"Getting Additional Help"}]}